[{"task":"average_window","language":"sql","plan":{"key":[{"line":2,"start":9,"end":30,"ntokens":12}],"group by":[{"line":2,"start":0,"end":8,"ntokens":4},{"line":1,"start":0,"end":9,"ntokens":3}],"average":[{"line":0,"start":7,"end":18,"ntokens":8}],"output_order":[{"line":3,"start":0,"end":13,"ntokens":5},{"line":3,"start":0,"end":13,"ntokens":5},{"line":3,"start":0,"end":13,"ntokens":5}]},"source":"SELECT AVG(x) as x\nFROM data\nGROUP BY cast(time \/ 7 as int)\nORDER BY time","author":"scott","implementation":"","ntokens":34,"category":"Time Series","language_name":"SQL - SQLite","task_name":"Windowed average","token_zscore":-0.9714595758,"plan_overlap":0},{"task":"average_window","language":"python-imperative","plan":{"key":[{"line":1,"start":2,"end":20,"ntokens":7},{"line":2,"start":4,"end":40,"ntokens":15}],"output_order":[{"line":5,"start":2,"end":36,"ntokens":15}],"group by":[{"line":9,"start":2,"end":24,"ntokens":12},{"line":10,"start":4,"end":31,"ntokens":8},{"line":11,"start":4,"end":37,"ntokens":8},{"line":7,"start":2,"end":34,"ntokens":10},{"line":3,"start":2,"end":19,"ntokens":11},{"line":4,"start":4,"end":13,"ntokens":4}],"average":[{"line":12,"start":6,"end":34,"ntokens":10},{"line":13,"start":6,"end":54,"ntokens":17},{"line":8,"start":2,"end":32,"ntokens":17},{"line":6,"start":2,"end":13,"ntokens":6},{"line":14,"start":4,"end":23,"ntokens":8},{"line":15,"start":4,"end":14,"ntokens":5},{"line":17,"start":2,"end":15,"ntokens":3},{"line":16,"start":2,"end":30,"ntokens":10}]},"source":"def average_window(data):\n  def window(value):\n    return math.floor(value[\"time\"] \/ 7)\n  if len(data) < 1:\n    return []\n  data.sort(key=lambda v: v[\"time\"])\n  result = []\n  current_window = window(data[0])\n  total, count = data[0][\"x\"], 1\n  for value in data[1:]:\n    time_window = window(value)\n    if time_window != current_window:\n      result.append(total \/ count)\n      current_window, total, count = time_window, 0, 0\n    total += value[\"x\"]\n    count += 1\n  result.append(total \/ count)\n  return result","author":"scott","implementation":"","ntokens":190,"category":"Time Series","language_name":"Python - Imperative","task_name":"Windowed average","token_zscore":1.9349345523,"plan_overlap":2},{"task":"average_window","language":"python-functional","plan":{"output_order":[{"line":5,"start":4,"end":35,"ntokens":15}],"group by":[{"line":3,"start":2,"end":20,"ntokens":5},{"line":4,"start":4,"end":56,"ntokens":25},{"line":5,"start":4,"end":35,"ntokens":15},{"line":6,"start":2,"end":3,"ntokens":1},{"line":9,"start":4,"end":32,"ntokens":7},{"line":7,"start":2,"end":10,"ntokens":3},{"line":10,"start":2,"end":3,"ntokens":1}],"key":[{"line":1,"start":2,"end":20,"ntokens":7},{"line":2,"start":4,"end":40,"ntokens":15}],"average":[{"line":8,"start":4,"end":29,"ntokens":11}]},"source":"def average_window(data):\n  def window(value):\n    return math.floor(value[\"time\"] \/ 7)\n  grouped_values = [\n    [point[\"x\"] for point in data if window(point) == w]\n    for w in set(map(window, data))\n  ]\n  return [\n    sum(values) \/ len(values)\n    for values in grouped_values\n  ]","author":"scott","implementation":"","ntokens":107,"category":"Time Series","language_name":"Python - Functional","task_name":"Windowed average","token_zscore":0.3885838303,"plan_overlap":2},{"task":"average_window","language":"python-pandas","plan":{"key":[{"line":1,"start":2,"end":16,"ntokens":7},{"line":2,"start":4,"end":28,"ntokens":12}],"output_order":[{"line":3,"start":12,"end":36,"ntokens":6}],"group by":[{"line":4,"start":35,"end":50,"ntokens":5},{"line":4,"start":17,"end":35,"ntokens":6},{"line":5,"start":2,"end":29,"ntokens":10},{"line":3,"start":2,"end":11,"ntokens":5}],"average":[{"line":4,"start":51,"end":57,"ntokens":3}]},"source":"def average_window(data):\n  def window(t):\n    return math.floor(t \/ 7)\n  result = (data.sort_values(\"time\")\n                .set_index(\"time\").groupby(window).mean())\n  return result['x'].tolist()","author":"scott","implementation":"","ntokens":66,"category":"Time Series","language_name":"Python - Pandas","task_name":"Windowed average","token_zscore":-0.3752761649,"plan_overlap":2},{"task":"average_window","language":"datalog","plan":{"average":[{"line":5,"start":18,"end":27,"ntokens":1},{"line":6,"start":2,"end":37,"ntokens":9},{"line":7,"start":6,"end":44,"ntokens":9}],"group by":[{"line":0,"start":0,"end":23,"ntokens":8},{"line":2,"start":0,"end":35,"ntokens":14},{"line":3,"start":0,"end":31,"ntokens":20},{"line":4,"start":0,"end":41,"ntokens":14},{"line":1,"start":0,"end":26,"ntokens":17}],"key":[{"line":1,"start":7,"end":10,"ntokens":1},{"line":3,"start":9,"end":12,"ntokens":1},{"line":1,"start":7,"end":10,"ntokens":1}],"output_order":[]},"source":".decl window(w: number)\nwindow(t\/7) :- data(t, _).\n.decl windowed(w: number, x: float)\nwindowed(t\/7, x) :- data(t, x).\n.decl windowed_total(w: number, x: float)\nwindowed_total(w, total \/ n) :- window(w),\n  total = sum x : { windowed(w, x) },\n      n = sum z : { windowed(w, x), z=1.0 }.\naverage_window(v) :- windowed_total(_, v).","author":"scott","implementation":"","ntokens":125,"category":"Time Series","language_name":"Datalog - Souffle","task_name":"Windowed average","token_zscore":0.7239369989,"plan_overlap":1},{"task":"average_window","language":"r","plan":{"average":[{"line":3,"start":4,"end":33,"ntokens":13},{"line":4,"start":4,"end":13,"ntokens":4}],"key":[{"line":2,"start":19,"end":27,"ntokens":6}],"group by":[{"line":1,"start":2,"end":11,"ntokens":4},{"line":2,"start":4,"end":19,"ntokens":5},{"line":2,"start":28,"end":33,"ntokens":4}]},"source":"average_window <- function(data) {\n  data %>% \n    group_by(floor(time \/ 7)) %>% \n    summarize(avg = mean(x)) %>% \n    pull(avg)\n}","author":"scott","implementation":"","ntokens":49,"category":"Time Series","language_name":"R - Tidyverse","task_name":"Windowed average","token_zscore":-0.6919986019,"plan_overlap":1},{"task":"average_window","language":"q","plan":{"output_order":[{"line":1,"start":15,"end":22,"ntokens":5}],"average":[{"line":1,"start":23,"end":28,"ntokens":4}],"key":[{"line":1,"start":32,"end":33,"ntokens":2}],"group by":[{"line":1,"start":29,"end":31,"ntokens":2},{"line":1,"start":34,"end":43,"ntokens":4}]},"source":"average_window:\n  (value select[<time] avg x by 7 xbar time from data) `x","author":"scott","implementation":"","ntokens":32,"category":"Time Series","language_name":"Q - kdb+","task_name":"Windowed average","token_zscore":-1.008721039,"plan_overlap":1},{"task":"changing_mean","language":"python-imperative","plan":{"remove":[{"line":10,"start":4,"end":34,"ntokens":19}],"new":[{"line":1,"start":0,"end":17,"ntokens":7},{"line":2,"start":2,"end":9,"ntokens":5},{"line":3,"start":2,"end":14,"ntokens":8},{"line":4,"start":4,"end":21,"ntokens":8},{"line":5,"start":2,"end":20,"ntokens":8},{"line":11,"start":4,"end":27,"ntokens":8},{"line":1,"start":0,"end":17,"ntokens":7},{"line":2,"start":2,"end":9,"ntokens":5},{"line":3,"start":2,"end":14,"ntokens":8},{"line":4,"start":4,"end":21,"ntokens":8},{"line":1,"start":0,"end":17,"ntokens":7},{"line":2,"start":2,"end":9,"ntokens":5},{"line":3,"start":2,"end":14,"ntokens":8},{"line":4,"start":4,"end":21,"ntokens":8},{"line":5,"start":2,"end":20,"ntokens":8},{"line":1,"start":0,"end":17,"ntokens":7},{"line":2,"start":2,"end":9,"ntokens":5},{"line":3,"start":2,"end":14,"ntokens":8},{"line":4,"start":4,"end":21,"ntokens":8},{"line":5,"start":2,"end":20,"ntokens":8}],"diff":[{"line":12,"start":4,"end":36,"ntokens":15}],"orig":[{"line":8,"start":2,"end":29,"ntokens":8},{"line":1,"start":0,"end":17,"ntokens":7},{"line":2,"start":2,"end":9,"ntokens":5},{"line":3,"start":2,"end":14,"ntokens":8},{"line":4,"start":4,"end":21,"ntokens":8},{"line":5,"start":2,"end":20,"ntokens":8},{"line":1,"start":0,"end":17,"ntokens":7},{"line":2,"start":2,"end":9,"ntokens":5},{"line":3,"start":2,"end":14,"ntokens":8},{"line":4,"start":4,"end":21,"ntokens":8},{"line":5,"start":2,"end":20,"ntokens":8},{"line":1,"start":0,"end":17,"ntokens":7},{"line":2,"start":2,"end":9,"ntokens":5},{"line":3,"start":2,"end":14,"ntokens":8},{"line":4,"start":4,"end":21,"ntokens":8},{"line":5,"start":2,"end":20,"ntokens":8},{"line":1,"start":0,"end":17,"ntokens":7},{"line":2,"start":2,"end":9,"ntokens":5},{"line":3,"start":2,"end":14,"ntokens":8},{"line":4,"start":4,"end":21,"ntokens":8},{"line":5,"start":2,"end":20,"ntokens":8},{"line":1,"start":0,"end":17,"ntokens":7},{"line":2,"start":2,"end":9,"ntokens":5},{"line":3,"start":2,"end":14,"ntokens":8},{"line":4,"start":4,"end":21,"ntokens":8},{"line":5,"start":2,"end":20,"ntokens":8},{"line":1,"start":0,"end":17,"ntokens":7},{"line":2,"start":2,"end":9,"ntokens":5},{"line":3,"start":2,"end":14,"ntokens":8},{"line":4,"start":4,"end":21,"ntokens":8},{"line":5,"start":2,"end":20,"ntokens":8},{"line":1,"start":0,"end":17,"ntokens":7},{"line":2,"start":2,"end":9,"ntokens":5},{"line":3,"start":2,"end":14,"ntokens":8},{"line":4,"start":4,"end":21,"ntokens":8},{"line":5,"start":2,"end":20,"ntokens":8},{"line":1,"start":0,"end":17,"ntokens":7},{"line":2,"start":2,"end":9,"ntokens":5},{"line":3,"start":2,"end":14,"ntokens":8},{"line":4,"start":4,"end":21,"ntokens":8},{"line":5,"start":2,"end":20,"ntokens":8},{"line":1,"start":0,"end":17,"ntokens":7},{"line":2,"start":2,"end":9,"ntokens":5},{"line":3,"start":2,"end":14,"ntokens":8},{"line":4,"start":4,"end":21,"ntokens":8},{"line":5,"start":2,"end":20,"ntokens":8},{"line":1,"start":0,"end":17,"ntokens":7},{"line":2,"start":2,"end":9,"ntokens":5},{"line":3,"start":2,"end":14,"ntokens":8},{"line":4,"start":4,"end":21,"ntokens":8},{"line":5,"start":2,"end":20,"ntokens":8},{"line":1,"start":0,"end":17,"ntokens":7},{"line":2,"start":2,"end":9,"ntokens":5}],"first":[{"line":13,"start":6,"end":14,"ntokens":3},{"line":14,"start":2,"end":13,"ntokens":3}]},"source":"\ndef get_mean(ls):\n  sum = 0\n  for e in ls:\n    sum += e['value']\n  return sum\/len(ls)\n\ndef changing_mean(vals):\n  start_mean = get_mean(vals)\n  for i,elem in enumerate(vals):\n    new_ls = vals[:i] + vals[i+1:]\n    mean = get_mean(new_ls)\n    if abs(mean - start_mean) < 0.1:\n      return i\n  return None\n","author":"g","implementation":"","ntokens":123,"category":"Aggregation","language_name":"Python - Imperative","task_name":"First element that doesn't change mean","token_zscore":1.2036088069,"plan_overlap":2},{"task":"changing_mean","language":"python-pandas","plan":{"diff":[{"line":4,"start":14,"end":47,"ntokens":16}],"new":[{"line":3,"start":2,"end":85,"ntokens":37},{"line":4,"start":9,"end":60,"ntokens":23}],"orig":[{"line":2,"start":2,"end":26,"ntokens":11}],"remove":[{"line":4,"start":9,"end":60,"ntokens":23},{"line":3,"start":45,"end":63,"ntokens":11}],"first":[{"line":4,"start":9,"end":60,"ntokens":23}]},"source":"\ndef changing_mean(vals):\n  mean = vals.value.mean()\n  mean_without = vals.apply(lambda row: vals[vals.id != row.id].value.mean(), axis=1)\n  return vals[(mean_without - mean).abs() < 0.1].id.tolist()\n","author":"g","implementation":"","ntokens":83,"category":"Aggregation","language_name":"Python - Pandas","task_name":"First element that doesn't change mean","token_zscore":-0.3566248317,"plan_overlap":6},{"task":"changing_mean","language":"r","plan":{"remove":[{"line":4,"start":43,"end":65,"ntokens":10}],"orig":[{"line":4,"start":38,"end":43,"ntokens":3},{"line":4,"start":65,"end":66,"ntokens":1},{"line":4,"start":24,"end":35,"ntokens":2},{"line":2,"start":3,"end":34,"ntokens":10}],"new":[{"line":4,"start":36,"end":37,"ntokens":2},{"line":4,"start":5,"end":24,"ntokens":7},{"line":4,"start":66,"end":68,"ntokens":2}],"first":[{"line":7,"start":5,"end":29,"ntokens":8},{"line":8,"start":5,"end":13,"ntokens":4},{"line":3,"start":3,"end":16,"ntokens":5},{"line":5,"start":5,"end":17,"ntokens":8}],"diff":[{"line":6,"start":5,"end":34,"ntokens":10}]},"source":"library(data.table)\nchanging_mean <- function(vals) {\n   global_mean <- mean(vals$value)\n   setDT(vals)[, \n     mean_change := abs(global_mean - mean(vals[id != .BY, value])), \n     by = id] %>%\n     filter(mean_change < 0.1) %>%\n     slice(which.min(id)) %>%\n     pull(id)\n}","author":"g","implementation":"","ntokens":90,"category":"Aggregation","language_name":"R - Tidyverse","task_name":"First element that doesn't change mean","token_zscore":-0.0835839449,"plan_overlap":7},{"task":"changing_mean","language":"q","plan":{"remove":[{"line":1,"start":44,"end":64,"ntokens":11}],"orig":[{"line":1,"start":7,"end":23,"ntokens":7},{"line":1,"start":26,"end":43,"ntokens":8}],"new":[{"line":1,"start":3,"end":6,"ntokens":2},{"line":1,"start":23,"end":26,"ntokens":4}],"diff":[{"line":4,"start":31,"end":48,"ntokens":7}],"first":[{"line":4,"start":15,"end":20,"ntokens":2},{"line":4,"start":20,"end":30,"ntokens":6}]},"source":"diffs: \n  {abs avg vals[`value] - avg (vals[`value] where vals[`id] <> x)} \n  each vals[`id];\n  \nchanging_mean: first vals[`id] where diffs < 0.1","author":"g","implementation":"","ntokens":64,"category":"Aggregation","language_name":"Q - kdb+","task_name":"First element that doesn't change mean","token_zscore":-1.09773581,"plan_overlap":1},{"task":"changing_mean","language":"sql","plan":{"diff":[{"line":6,"start":35,"end":40,"ntokens":3},{"line":2,"start":6,"end":11,"ntokens":2}],"new":[{"line":3,"start":2,"end":19,"ntokens":6},{"line":4,"start":2,"end":14,"ntokens":5},{"line":5,"start":2,"end":22,"ntokens":11},{"line":2,"start":6,"end":11,"ntokens":2},{"line":3,"start":2,"end":19,"ntokens":6},{"line":4,"start":2,"end":14,"ntokens":5},{"line":5,"start":2,"end":22,"ntokens":11},{"line":6,"start":0,"end":34,"ntokens":17}],"orig":[{"line":6,"start":5,"end":32,"ntokens":11}],"remove":[{"line":5,"start":2,"end":22,"ntokens":11},{"line":5,"start":2,"end":22,"ntokens":11}],"first":[{"line":0,"start":0,"end":9,"ntokens":3}]},"source":"SELECT id\nFROM vals v1\nWHERE ABS((\n  SELECT AVG(value)\n  FROM vals v2\n  WHERE v1.id != v2.id\n) - (SELECT AVG(value) FROM vals)) < 0.1","author":"g","implementation":"","ntokens":57,"category":"Aggregation","language_name":"SQL - SQLite","task_name":"First element that doesn't change mean","token_zscore":-1.3707766968,"plan_overlap":5},{"task":"changing_mean","language":"datalog","plan":{"orig":[{"line":9,"start":2,"end":27,"ntokens":9},{"line":10,"start":2,"end":29,"ntokens":9},{"line":11,"start":2,"end":18,"ntokens":1}],"new":[{"line":12,"start":2,"end":27,"ntokens":8},{"line":1,"start":0,"end":22,"ntokens":10},{"line":2,"start":2,"end":13,"ntokens":8},{"line":3,"start":2,"end":39,"ntokens":9},{"line":4,"start":2,"end":41,"ntokens":9},{"line":5,"start":2,"end":18,"ntokens":1}],"diff":[{"line":13,"start":2,"end":44,"ntokens":1},{"line":14,"start":3,"end":45,"ntokens":1}],"first":[{"line":8,"start":7,"end":8,"ntokens":1}],"remove":[{"line":3,"start":2,"end":39,"ntokens":9},{"line":4,"start":2,"end":41,"ntokens":9}]},"source":".decl avg_except(I:number, Avg:float)    \navg_except(I, Avg) :- \n  vals(I, _),\n  N = sum 1.0 : { vals(J, _), I != J },\n  Total = sum V : { vals(J, V), I != J },\n  Avg = Total \/ N.\n  \nchanging_mean(I) :-\n  vals(I, _),\n  N = sum 1.0 : vals(_, _),\n  Total = sum V : vals(_, V),\n  Avg = Total \/ N,\n  avg_except(I, AvgExcept),\n  ((Avg > AvgExcept, Avg - AvgExcept < 0.1);\n   (Avg < AvgExcept, AvgExcept - Avg < 0.1)).","author":"g","implementation":"","ntokens":97,"category":"Aggregation","language_name":"Datalog - Souffle","task_name":"First element that doesn't change mean","token_zscore":0.1894569418,"plan_overlap":3},{"task":"changing_mean","language":"python-functional","plan":{"remove":[{"line":6,"start":4,"end":52,"ntokens":26}],"diff":[{"line":8,"start":4,"end":35,"ntokens":13},{"line":3,"start":2,"end":34,"ntokens":20}],"new":[{"line":6,"start":4,"end":52,"ntokens":26},{"line":7,"start":4,"end":34,"ntokens":13},{"line":1,"start":0,"end":24,"ntokens":7},{"line":2,"start":2,"end":56,"ntokens":24},{"line":3,"start":2,"end":34,"ntokens":20}],"orig":[{"line":2,"start":2,"end":56,"ntokens":24},{"line":1,"start":0,"end":24,"ntokens":7}],"first":[{"line":9,"start":6,"end":14,"ntokens":3},{"line":10,"start":2,"end":13,"ntokens":3}]},"source":"\ndef changing_mean(vals):\n  start_mean = sum([l['value'] for l in vals])\/len(vals)\n  diff = lambda m, sm: abs(m - sm)\n    \n  for i,elem in enumerate(vals):\n    new_ls = [x['value'] for x in vals if x != elem]\n    mean = sum(new_ls)\/len(new_ls)\n    if diff(mean,start_mean) < 0.1:\n      return i\n  return None\n","author":"g","implementation":"","ntokens":131,"category":"Aggregation","language_name":"Python - Functional","task_name":"First element that doesn't change mean","token_zscore":1.5156555346,"plan_overlap":4},{"task":"continent_by_population","language":"python-pandas","plan":{"group":[{"line":1,"start":22,"end":43,"ntokens":6}],"average":[{"line":1,"start":43,"end":61,"ntokens":6}],"max":[{"line":2,"start":24,"end":41,"ntokens":5}],"name":[{"line":2,"start":9,"end":24,"ntokens":5},{"line":2,"start":41,"end":42,"ntokens":1}]},"source":"def continent_by_population(countries):\n  mean_pop = countries.groupby('continent').population.mean()\n  return mean_pop.index[mean_pop.argmax()]","author":"will","implementation":"","ntokens":36,"category":"Aggregation","language_name":"Python - Pandas","task_name":"Continent with the highest average population","token_zscore":-0.8804210357,"plan_overlap":1},{"task":"continent_by_population","language":"sql","plan":{"max":[{"line":3,"start":25,"end":29,"ntokens":1},{"line":3,"start":0,"end":8,"ntokens":4},{"line":4,"start":0,"end":7,"ntokens":3}],"average":[{"line":3,"start":9,"end":24,"ntokens":5}],"group":[{"line":2,"start":0,"end":18,"ntokens":5},{"line":1,"start":0,"end":14,"ntokens":3}],"name":[{"line":0,"start":0,"end":16,"ntokens":4}]},"source":"SELECT continent \nFROM countries\nGROUP BY continent\nORDER BY AVG(population) DESC\nLIMIT 1","author":"will","implementation":"","ntokens":25,"category":"Aggregation","language_name":"SQL - SQLite","task_name":"Continent with the highest average population","token_zscore":-1.1174574684,"plan_overlap":1},{"task":"continent_by_population","language":"datalog","plan":{"max":[{"line":10,"start":2,"end":69,"ntokens":20},{"line":9,"start":2,"end":41,"ntokens":8}],"group":[{"line":3,"start":18,"end":45,"ntokens":11},{"line":4,"start":26,"end":53,"ntokens":11}],"name":[{"line":8,"start":2,"end":29,"ntokens":11},{"line":7,"start":24,"end":33,"ntokens":1}],"average":[{"line":5,"start":2,"end":30,"ntokens":3},{"line":4,"start":2,"end":26,"ntokens":1},{"line":3,"start":2,"end":18,"ntokens":1},{"line":2,"start":2,"end":29,"ntokens":11},{"line":0,"start":0,"end":54,"ntokens":12},{"line":1,"start":0,"end":37,"ntokens":9}]},"source":".decl average_population(Continent:symbol, Avg:number)\naverage_population(Continent, Avg) :-\n  countries(Continent, _, _),\n  Total = sum P : countries(Continent, _, P),\n  Num_countries = count : countries(Continent, _, _),\n  Avg = Total \/ Num_countries.\n  \ncontinent_by_population(Continent) :- \n  countries(Continent, _, _), \n  average_population(Continent, Max_avg),\n  Max_avg = max A : { countries(C, _, _), average_population(C, A) }.","author":"will","implementation":"","ntokens":109,"category":"Aggregation","language_name":"Datalog - Souffle","task_name":"Continent with the highest average population","token_zscore":0.6926389267,"plan_overlap":1},{"task":"continent_by_population","language":"q","plan":{"max":[{"line":3,"start":3,"end":8,"ntokens":2},{"line":3,"start":15,"end":28,"ntokens":5}],"average":[{"line":1,"start":9,"end":24,"ntokens":5},{"line":1,"start":2,"end":9,"ntokens":3}],"name":[{"line":3,"start":29,"end":38,"ntokens":2},{"line":3,"start":54,"end":64,"ntokens":1}],"group":[{"line":1,"start":25,"end":52,"ntokens":8}]},"source":"averages: \n  select avg(population) by continent from countries;\ncontinent_by_population: \n  (first select[>population] continent from averages) `continent","author":"will","implementation":"","ntokens":44,"category":"Aggregation","language_name":"Q - kdb+","task_name":"Continent with the highest average population","token_zscore":-0.7080309028,"plan_overlap":0},{"task":"continent_by_population","language":"python-functional","plan":{"group":[{"line":3,"start":33,"end":52,"ntokens":8},{"line":4,"start":17,"end":48,"ntokens":11}],"name":[{"line":6,"start":2,"end":3,"ntokens":1},{"line":2,"start":29,"end":30,"ntokens":1},{"line":8,"start":5,"end":15,"ntokens":3},{"line":9,"start":8,"end":18,"ntokens":3},{"line":11,"start":42,"end":45,"ntokens":3},{"line":11,"start":2,"end":8,"ntokens":2},{"line":3,"start":5,"end":15,"ntokens":3},{"line":5,"start":4,"end":31,"ntokens":7},{"line":1,"start":2,"end":55,"ntokens":19},{"line":2,"start":2,"end":30,"ntokens":5},{"line":7,"start":2,"end":14,"ntokens":5},{"line":9,"start":4,"end":7,"ntokens":2},{"line":9,"start":24,"end":51,"ntokens":3},{"line":10,"start":2,"end":3,"ntokens":1}],"max":[{"line":11,"start":9,"end":42,"ntokens":17}],"average":[{"line":8,"start":16,"end":37,"ntokens":11},{"line":9,"start":19,"end":23,"ntokens":2},{"line":3,"start":17,"end":32,"ntokens":5},{"line":9,"start":24,"end":51,"ntokens":3},{"line":9,"start":4,"end":7,"ntokens":2},{"line":10,"start":2,"end":3,"ntokens":1},{"line":7,"start":2,"end":14,"ntokens":5},{"line":2,"start":2,"end":30,"ntokens":5},{"line":6,"start":2,"end":3,"ntokens":1},{"line":5,"start":4,"end":31,"ntokens":7}]},"source":"def continent_by_population(countries):\n  continents = set([c['continent'] for c in countries])\n  populations_by_continent = [\n    (continent, [c['population'] for c in countries \n                 if c['continent'] == continent])\n    for continent in continents\n  ]\n  averages = [\n    (continent, sum(pops) \/ len(pops))\n    for continent, pops in populations_by_continent\n  ]\n  return max(averages, key=lambda t: t[1])[0]","author":"will","implementation":"","ntokens":131,"category":"Aggregation","language_name":"Python - Functional","task_name":"Continent with the highest average population","token_zscore":1.1667117921,"plan_overlap":4},{"task":"continent_by_population","language":"python-imperative","plan":{"name":[{"line":15,"start":2,"end":22,"ntokens":3},{"line":7,"start":2,"end":22,"ntokens":5},{"line":13,"start":6,"end":31,"ntokens":5},{"line":9,"start":2,"end":16,"ntokens":5},{"line":9,"start":32,"end":59,"ntokens":8},{"line":3,"start":4,"end":36,"ntokens":8},{"line":1,"start":2,"end":32,"ntokens":7},{"line":1,"start":46,"end":47,"ntokens":1},{"line":4,"start":4,"end":30,"ntokens":5},{"line":5,"start":4,"end":30,"ntokens":5}],"max":[{"line":11,"start":4,"end":52,"ntokens":16},{"line":12,"start":6,"end":27,"ntokens":5},{"line":8,"start":2,"end":20,"ntokens":5},{"line":9,"start":2,"end":5,"ntokens":2},{"line":9,"start":32,"end":59,"ntokens":8}],"average":[{"line":9,"start":17,"end":31,"ntokens":7},{"line":10,"start":4,"end":27,"ntokens":9},{"line":4,"start":30,"end":58,"ntokens":10},{"line":5,"start":30,"end":38,"ntokens":7}],"group":[{"line":2,"start":2,"end":27,"ntokens":8},{"line":3,"start":16,"end":36,"ntokens":4}]},"source":"def continent_by_population(countries):\n  continent_stats = defaultdict(lambda: [0, 0])\n  for country in countries:\n    continent = country['continent']\n    continent_stats[continent][0] += country['population']\n    continent_stats[continent][1] += 1\n     \n  max_continent = None\n  max_average = None\n  for continent, [total, count] in continent_stats.items():\n    average = total \/ count\n    if max_average is None or max_average < average:\n      max_average = average\n      max_continent = continent\n      \n  return max_continent","author":"will","implementation":"","ntokens":146,"category":"Aggregation","language_name":"Python - Imperative","task_name":"Continent with the highest average population","token_zscore":1.4899432912,"plan_overlap":4},{"task":"continent_by_population","language":"r","plan":{"name":[{"line":5,"start":4,"end":15,"ntokens":3},{"line":4,"start":31,"end":34,"ntokens":1}],"max":[{"line":4,"start":4,"end":30,"ntokens":7},{"line":3,"start":43,"end":46,"ntokens":1}],"average":[{"line":3,"start":4,"end":42,"ntokens":11},{"line":2,"start":24,"end":27,"ntokens":1}],"group":[{"line":1,"start":12,"end":15,"ntokens":1},{"line":2,"start":4,"end":23,"ntokens":5},{"line":1,"start":2,"end":12,"ntokens":2}]},"source":"continent_by_population <- function(countries) {\n  countries %>%\n    group_by(continent) %>%\n    summarize(mean_pop = mean(population)) %>%\n    slice(which.max(mean_pop)) %>%\n    .$continent\n}","author":"will","implementation":"","ntokens":47,"category":"Aggregation","language_name":"R - Tidyverse","task_name":"Continent with the highest average population","token_zscore":-0.643384603,"plan_overlap":0},{"task":"continent_median_population","language":"python-pandas","plan":{"name":[{"line":4,"start":6,"end":20,"ntokens":4},{"line":4,"start":21,"end":21,"ntokens":0}],"agg":[{"line":3,"start":6,"end":26,"ntokens":6}],"iter":[{"line":2,"start":6,"end":27,"ntokens":5}],"group":[{"line":1,"start":10,"end":19,"ntokens":1}]},"source":"def continent_median_population(countries):\n  return (countries\n      .groupby('continent')\n      .population.median()\n      .reset_index())","author":"will","implementation":"","ntokens":30,"category":"Aggregation","language_name":"Python - Pandas","task_name":"Median population for each continent","token_zscore":-1.096022361,"plan_overlap":0},{"task":"continent_median_population","language":"sql","plan":{"name":[{"line":0,"start":7,"end":16,"ntokens":2}],"agg":[{"line":0,"start":18,"end":47,"ntokens":8},{"line":2,"start":2,"end":13,"ntokens":3},{"line":3,"start":4,"end":21,"ntokens":6},{"line":4,"start":30,"end":59,"ntokens":11},{"line":5,"start":4,"end":16,"ntokens":6},{"line":6,"start":31,"end":39,"ntokens":3},{"line":7,"start":2,"end":17,"ntokens":4},{"line":8,"start":0,"end":6,"ntokens":2},{"line":9,"start":2,"end":48,"ntokens":32},{"line":10,"start":2,"end":55,"ntokens":34}],"group":[{"line":4,"start":7,"end":29,"ntokens":6},{"line":6,"start":7,"end":29,"ntokens":6}],"iter":[{"line":11,"start":0,"end":18,"ntokens":5}]},"source":"SELECT continent, AVG(population) as population\nFROM\n  (SELECT *, \n    row_number() OVER \n      (PARTITION BY continent ORDER BY population) AS rank, \n    count() OVER \n      (PARTITION BY continent) as count\n  FROM countries)\nWHERE \n  (count % 2 = 1 AND rank = (count + 1) \/ 2) OR \n  (count % 2 = 0 AND ABS(rank - 0.5 - count \/ 2) = 0.5)\nGROUP BY continent","author":"will","implementation":"","ntokens":142,"category":"Aggregation","language_name":"SQL - SQLite","task_name":"Median population for each continent","token_zscore":0.2899155923,"plan_overlap":1},{"task":"continent_median_population","language":"datalog","plan":{"iter":[{"line":20,"start":2,"end":29,"ntokens":11}],"name":[{"line":20,"start":12,"end":21,"ntokens":1},{"line":19,"start":28,"end":37,"ntokens":1}],"agg":[{"line":19,"start":39,"end":45,"ntokens":1},{"line":21,"start":2,"end":53,"ntokens":12},{"line":22,"start":2,"end":27,"ntokens":3},{"line":23,"start":4,"end":54,"ntokens":13},{"line":24,"start":3,"end":26,"ntokens":3},{"line":25,"start":4,"end":47,"ntokens":19},{"line":26,"start":4,"end":43,"ntokens":15},{"line":27,"start":4,"end":28,"ntokens":1},{"line":0,"start":0,"end":46,"ntokens":13},{"line":1,"start":0,"end":50,"ntokens":21},{"line":2,"start":0,"end":0,"ntokens":0},{"line":3,"start":0,"end":56,"ntokens":17},{"line":4,"start":0,"end":45,"ntokens":16},{"line":5,"start":2,"end":44,"ntokens":11},{"line":6,"start":2,"end":25,"ntokens":8},{"line":7,"start":2,"end":21,"ntokens":1},{"line":8,"start":4,"end":32,"ntokens":11},{"line":9,"start":4,"end":22,"ntokens":8},{"line":10,"start":4,"end":18,"ntokens":1},{"line":11,"start":2,"end":4,"ntokens":1},{"line":12,"start":2,"end":18,"ntokens":1},{"line":13,"start":4,"end":32,"ntokens":11},{"line":14,"start":4,"end":22,"ntokens":8},{"line":15,"start":4,"end":20,"ntokens":1},{"line":16,"start":4,"end":12,"ntokens":1},{"line":17,"start":2,"end":4,"ntokens":1}],"group":[{"line":21,"start":26,"end":52,"ntokens":11},{"line":8,"start":14,"end":23,"ntokens":1},{"line":5,"start":12,"end":21,"ntokens":1}]},"source":".decl unique_id(Country:symbol, Id:number)    \nunique_id(Country, $) :- countries(_, Country, _).\n\n.decl rank(Continent:symbol, R:number, Population:float)\nrank(Continent, R_less + R_eq, Population) :-\n  countries(Continent, Country, Population),\n  unique_id(Country, Id),\n  R_less = count : { \n    countries(Continent, C, P), \n    unique_id(C, Id2),\n    P < Population\n  },\n  R_eq = count : {\n    countries(Continent, C, P), \n    unique_id(C, Id2),\n    P = Population, \n    Id2 < Id\n  }.\n\ncontinent_median_population(Continent, Median) :-\n  countries(Continent, _, _),\n  Num_countries = count : countries(Continent, _, _),\n  ((Num_countries % 2 = 1, \n    rank(Continent, (Num_countries - 1) \/ 2, Median));\n   (Num_countries % 2 = 0,\n    rank(Continent, Num_countries \/ 2 - 1, P1),\n    rank(Continent, Num_countries \/ 2, P2),\n    Median = (P1 + P2) \/ 2)).     ","author":"will","implementation":"","ntokens":227,"category":"Aggregation","language_name":"Datalog - Souffle","task_name":"Median population for each continent","token_zscore":1.3417435032,"plan_overlap":6},{"task":"continent_median_population","language":"q","plan":{"agg":[{"line":1,"start":17,"end":32,"ntokens":5}],"iter":[{"line":1,"start":33,"end":45,"ntokens":4}],"group":[{"line":1,"start":46,"end":60,"ntokens":3}],"name":[{"line":1,"start":33,"end":45,"ntokens":4}]},"source":"continent_median_population:\n  () xkey select med[population] by continent from countries","author":"will","implementation":"","ntokens":26,"category":"Aggregation","language_name":"Q - kdb+","task_name":"Median population for each continent","token_zscore":-1.145520145,"plan_overlap":1},{"task":"continent_median_population","language":"python-functional","plan":{"iter":[{"line":1,"start":2,"end":55,"ntokens":19},{"line":7,"start":4,"end":31,"ntokens":7},{"line":3,"start":4,"end":13,"ntokens":2},{"line":20,"start":4,"end":46,"ntokens":14},{"line":18,"start":2,"end":10,"ntokens":3},{"line":21,"start":2,"end":3,"ntokens":1}],"group":[{"line":4,"start":22,"end":41,"ntokens":8},{"line":5,"start":6,"end":36,"ntokens":10},{"line":6,"start":4,"end":5,"ntokens":1},{"line":3,"start":15,"end":16,"ntokens":1}],"agg":[{"line":4,"start":6,"end":21,"ntokens":5},{"line":2,"start":2,"end":17,"ntokens":5},{"line":8,"start":2,"end":3,"ntokens":1},{"line":10,"start":2,"end":27,"ntokens":7},{"line":11,"start":4,"end":23,"ntokens":8},{"line":12,"start":4,"end":17,"ntokens":8},{"line":13,"start":4,"end":18,"ntokens":12},{"line":14,"start":6,"end":31,"ntokens":15},{"line":15,"start":4,"end":9,"ntokens":2},{"line":16,"start":6,"end":50,"ntokens":31},{"line":19,"start":29,"end":63,"ntokens":7}],"name":[{"line":19,"start":5,"end":27,"ntokens":5}]},"source":"def continent_median_population(countries):\n  continents = set([c['continent'] for c in countries])\n  populations = {\n    continent: [\n      c['population'] for c in countries \n      if c['continent'] == continent\n    ]\n    for continent in continents\n  }\n  \n  def compute_median(pops):\n    pops = sorted(pops)\n    N = len(pops)\n    if N % 2 == 1:\n      return pops[(N - 1) \/\/ 2]\n    else:\n      return (pops[N \/\/ 2 - 1] + pops[N \/\/ 2]) \/ 2  \n   \n  return [\n    {\"continent\": continent, \"population\": compute_median(pops)}\n    for continent, pops in populations.items()\n  ]","author":"will","implementation":"","ntokens":203,"category":"Aggregation","language_name":"Python - Functional","task_name":"Median population for each continent","token_zscore":1.044756799,"plan_overlap":5},{"task":"continent_median_population","language":"python-imperative","plan":{"iter":[{"line":3,"start":16,"end":36,"ntokens":4},{"line":6,"start":6,"end":15,"ntokens":2},{"line":6,"start":22,"end":45,"ntokens":8},{"line":13,"start":4,"end":19,"ntokens":4},{"line":16,"start":4,"end":6,"ntokens":1},{"line":5,"start":2,"end":13,"ntokens":7},{"line":6,"start":2,"end":6,"ntokens":3},{"line":18,"start":2,"end":15,"ntokens":3}],"group":[{"line":2,"start":2,"end":27,"ntokens":8},{"line":3,"start":45,"end":52,"ntokens":2}],"agg":[{"line":1,"start":2,"end":33,"ntokens":8},{"line":3,"start":4,"end":16,"ntokens":3},{"line":3,"start":36,"end":45,"ntokens":5},{"line":3,"start":52,"end":67,"ntokens":3},{"line":6,"start":17,"end":45,"ntokens":10},{"line":7,"start":4,"end":15,"ntokens":5},{"line":8,"start":4,"end":17,"ntokens":8},{"line":9,"start":4,"end":18,"ntokens":12},{"line":10,"start":6,"end":33,"ntokens":17},{"line":11,"start":4,"end":9,"ntokens":2},{"line":12,"start":6,"end":52,"ntokens":32},{"line":15,"start":6,"end":26,"ntokens":4},{"line":6,"start":2,"end":6,"ntokens":3}],"name":[{"line":14,"start":6,"end":29,"ntokens":5}]},"source":"def continent_median_population(countries):\n  populations = defaultdict(list)\n  for country in countries:\n    populations[country['continent']].append(country['population'])\n  \n  output = []  \n  for continent, pops in populations.items():\n    pops.sort()\n    N = len(pops)\n    if N % 2 == 1:\n      median = pops[(N - 1) \/\/ 2]\n    else:\n      median = (pops[N \/\/ 2 - 1] + pops[N \/\/ 2]) \/ 2\n    output.append({\n      \"continent\": continent,\n      \"population\": median\n    })\n    \n  return output","author":"will","implementation":"","ntokens":169,"category":"Aggregation","language_name":"Python - Imperative","task_name":"Median population for each continent","token_zscore":0.6240256346,"plan_overlap":5},{"task":"continent_median_population","language":"r","plan":{"iter":[{"line":1,"start":2,"end":15,"ntokens":3}],"group":[{"line":2,"start":4,"end":27,"ntokens":6}],"agg":[{"line":3,"start":4,"end":46,"ntokens":10}],"name":[{"line":1,"start":2,"end":15,"ntokens":3}]},"source":"continent_median_population <- function(countries) {\n  countries %>%\n    group_by(continent) %>%\n    summarize(population = median(population))\n}","author":"will","implementation":"","ntokens":33,"category":"Aggregation","language_name":"R - Tidyverse","task_name":"Median population for each continent","token_zscore":-1.058899023,"plan_overlap":1},{"task":"documents_with_infrequent_words","language":"python-pandas","plan":{"word":[{"line":1,"start":2,"end":52,"ntokens":19}],"frequency":[{"line":2,"start":2,"end":37,"ntokens":13},{"line":3,"start":2,"end":49,"ntokens":16}],"documents":[{"line":4,"start":2,"end":30,"ntokens":6},{"line":5,"start":4,"end":44,"ntokens":11},{"line":6,"start":2,"end":45,"ntokens":13}]},"source":"def documents_with_infrequent_words(documents):\n  words = documents.text.str.split(\" \", expand=True)\n  freq = words.stack().value_counts()\n  infrequent_words = freq[freq == 1].index.values\n  infrequent_docs = documents[\n    np.isin(words.values, infrequent_words)]\n  return infrequent_docs.id.unique().tolist()","author":"will","implementation":"","ntokens":91,"category":"Strings","language_name":"Python - Pandas","task_name":"Documents with infrequent words","token_zscore":-0.9078825261,"plan_overlap":0},{"task":"documents_with_infrequent_words","language":"sql","plan":{"word":[{"line":3,"start":0,"end":42,"ntokens":12},{"line":4,"start":2,"end":52,"ntokens":13},{"line":5,"start":0,"end":51,"ntokens":14},{"line":6,"start":0,"end":51,"ntokens":15}],"documents":[{"line":8,"start":0,"end":18,"ntokens":5},{"line":9,"start":0,"end":5,"ntokens":2},{"line":10,"start":2,"end":11,"ntokens":1},{"line":11,"start":2,"end":12,"ntokens":3},{"line":14,"start":26,"end":38,"ntokens":1},{"line":12,"start":2,"end":23,"ntokens":6},{"line":13,"start":3,"end":13,"ntokens":3},{"line":16,"start":2,"end":44,"ntokens":16},{"line":17,"start":2,"end":36,"ntokens":14},{"line":18,"start":2,"end":36,"ntokens":14},{"line":19,"start":2,"end":25,"ntokens":10},{"line":15,"start":0,"end":5,"ntokens":1}],"frequency":[{"line":14,"start":3,"end":24,"ntokens":8}]},"source":"-- NOTE: SQLite tokenize is case-insensitive by default, \n-- so this solution is NOT exactly like the others\n\nCREATE VIRTUAL TABLE doc_index USING fts4(\n  text, id, content=documents, tokenize=simple);    \nINSERT INTO doc_index(doc_index) VALUES('rebuild');\nCREATE VIRTUAL TABLE words USING fts4aux(doc_index);    \n\nSELECT DISTINCT id\nFROM \n  documents\n  CROSS JOIN\n  (SELECT DISTINCT term\n   FROM words\n   WHERE occurrences = 1) unique_words\nWHERE\n  (LOWER(text) LIKE '% ' || term || ' %') OR\n  (LOWER(text) LIKE term || ' %') OR\n  (LOWER(text) LIKE '% ' || term) OR\n  (LOWER(text) LIKE term)","author":"will","implementation":"","ntokens":151,"category":"Strings","language_name":"SQL - SQLite","task_name":"Documents with infrequent words","token_zscore":0.0825347751,"plan_overlap":1},{"task":"documents_with_infrequent_words","language":"datalog","plan":{"word":[{"line":0,"start":0,"end":50,"ntokens":17},{"line":1,"start":0,"end":23,"ntokens":13},{"line":2,"start":2,"end":39,"ntokens":13},{"line":3,"start":0,"end":27,"ntokens":15},{"line":4,"start":2,"end":49,"ntokens":16},{"line":5,"start":0,"end":29,"ntokens":15},{"line":6,"start":2,"end":57,"ntokens":16},{"line":8,"start":0,"end":63,"ntokens":22},{"line":9,"start":0,"end":32,"ntokens":15},{"line":10,"start":2,"end":25,"ntokens":8},{"line":11,"start":2,"end":26,"ntokens":11},{"line":12,"start":2,"end":35,"ntokens":1},{"line":13,"start":2,"end":42,"ntokens":12},{"line":14,"start":2,"end":53,"ntokens":17},{"line":15,"start":2,"end":32,"ntokens":12},{"line":16,"start":2,"end":23,"ntokens":11}],"frequency":[{"line":21,"start":2,"end":35,"ntokens":15}],"documents":[{"line":19,"start":2,"end":19,"ntokens":8},{"line":20,"start":2,"end":24,"ntokens":14}]},"source":".decl substrs(Text:symbol, Idx:number, Len:number)\nsubstrs(Text, 0, 1) :- \n  documents(_, Text), strlen(Text) > 0.\nsubstrs(Text, 0, Len+1) :- \n  substrs(Text, 0, Len), Len + 1 <= strlen(Text).\nsubstrs(Text, Idx+1, Len) :- \n  substrs(Text, Idx, Len), Idx + Len + 1 <= strlen(Text).\n\n.decl token(Docid:number, Text:symbol, Idx:number, Word:symbol)\ntoken(Docid, Text, Idx, Word) :-\n  documents(Docid, Text),\n  substrs(Text, Idx, Len),\n  Prev = Idx - 1, Next = Idx + Len,\n  (Prev < 0; \" \" = substr(Text, Prev, 1)),\n  (Next = strlen(Text); \" \" = substr(Text, Next, 1)),\n  Word = substr(Text, Idx, Len),\n  !contains(\" \", Word).\n\ndocuments_with_infrequent_words(Id) :-\n  documents(Id, _),\n  token(Id, _, _, Word),\n  1 = count : token(_, _, _, Word).","author":"will","implementation":"","ntokens":264,"category":"Strings","language_name":"Datalog - Souffle","task_name":"Documents with infrequent words","token_zscore":1.9478206924,"plan_overlap":0},{"task":"documents_with_infrequent_words","language":"q","plan":{"word":[{"line":0,"start":0,"end":38,"ntokens":16}],"frequency":[{"line":1,"start":0,"end":34,"ntokens":13},{"line":2,"start":0,"end":20,"ntokens":10}],"documents":[{"line":4,"start":2,"end":70,"ntokens":29}]},"source":"words: (\" \" vs) each documents[`text];\nfreq: count each group raze words;\nuniq: where[freq=1];\ndocuments_with_infrequent_words:\n  (select id from documents where '[any; in\\: [;uniq]] each words) `id","author":"will","implementation":"","ntokens":77,"category":"Strings","language_name":"Q - kdb+","task_name":"Documents with infrequent words","token_zscore":-1.1389798964,"plan_overlap":0},{"task":"documents_with_infrequent_words","language":"python-functional","plan":{"word":[{"line":1,"start":2,"end":55,"ntokens":23}],"frequency":[{"line":2,"start":2,"end":46,"ntokens":23},{"line":3,"start":2,"end":10,"ntokens":5},{"line":4,"start":4,"end":33,"ntokens":10},{"line":5,"start":4,"end":31,"ntokens":10},{"line":6,"start":2,"end":3,"ntokens":1},{"line":7,"start":2,"end":26,"ntokens":6},{"line":8,"start":4,"end":41,"ntokens":17},{"line":9,"start":4,"end":17,"ntokens":7},{"line":10,"start":2,"end":4,"ntokens":1}],"documents":[{"line":11,"start":2,"end":21,"ntokens":5},{"line":12,"start":4,"end":53,"ntokens":22},{"line":13,"start":4,"end":42,"ntokens":17},{"line":14,"start":2,"end":3,"ntokens":1},{"line":15,"start":2,"end":24,"ntokens":3}]},"source":"def documents_with_infrequent_words(documents):\n  words = [doc[\"text\"].split(\" \") for doc in documents]\n  words_flat = [w for ws in words for w in ws]\n  freq = {\n    word: words_flat.count(word) \n    for word in set(words_flat)\n  }\n  infrequent_words = set([\n    word for word, count in freq.items() \n    if count == 1\n  ])\n  infrequent_docs = [\n    documents[i][\"id\"] for i, ws in enumerate(words) \n    if len(set(ws) & infrequent_words) > 0\n  ]\n  return infrequent_docs","author":"will","implementation":"","ntokens":173,"category":"Strings","language_name":"Python - Functional","task_name":"Documents with infrequent words","token_zscore":0.4456877855,"plan_overlap":0},{"task":"documents_with_infrequent_words","language":"python-imperative","plan":{"word":[{"line":4,"start":23,"end":45,"ntokens":9}],"frequency":[{"line":1,"start":1,"end":12,"ntokens":7},{"line":2,"start":2,"end":25,"ntokens":8},{"line":3,"start":2,"end":23,"ntokens":8},{"line":4,"start":4,"end":22,"ntokens":9},{"line":5,"start":4,"end":33,"ntokens":13},{"line":6,"start":6,"end":21,"ntokens":8},{"line":8,"start":2,"end":26,"ntokens":7},{"line":9,"start":2,"end":34,"ntokens":15},{"line":10,"start":4,"end":18,"ntokens":8},{"line":11,"start":6,"end":32,"ntokens":6}],"documents":[{"line":13,"start":2,"end":22,"ntokens":6},{"line":14,"start":2,"end":23,"ntokens":8},{"line":15,"start":4,"end":33,"ntokens":13},{"line":16,"start":6,"end":34,"ntokens":8},{"line":17,"start":8,"end":41,"ntokens":8},{"line":18,"start":8,"end":13,"ntokens":1},{"line":20,"start":0,"end":24,"ntokens":4}]},"source":"def documents_with_infrequent_words(documents):\n  words = {}\n  freq = defaultdict(int)\n  for doc in documents:\n    words[doc[\"id\"]] = doc[\"text\"].split(\" \")\n    for word in words[doc[\"id\"]]:\n      freq[word] += 1\n      \n  infrequent_words = set()\n  for word, count in freq.items():\n    if count == 1:\n      infrequent_words.add(word)\n      \n  infrequent_docs = []\n  for doc in documents:\n    for word in words[doc[\"id\"]]:\n      if word in infrequent_words:\n        infrequent_docs.append(doc[\"id\"])\n        break\n        \n  return infrequent_docs","author":"will","implementation":"","ntokens":171,"category":"Strings","language_name":"Python - Imperative","task_name":"Documents with infrequent words","token_zscore":0.4126738755,"plan_overlap":1},{"task":"documents_with_infrequent_words","language":"r","plan":{"documents":[{"line":6,"start":2,"end":12,"ntokens":4},{"line":7,"start":4,"end":43,"ntokens":12},{"line":8,"start":4,"end":16,"ntokens":6},{"line":9,"start":4,"end":12,"ntokens":2}],"frequency":[{"line":4,"start":2,"end":31,"ntokens":12},{"line":5,"start":2,"end":41,"ntokens":16}],"word":[{"line":1,"start":2,"end":24,"ntokens":7},{"line":2,"start":4,"end":43,"ntokens":14},{"line":3,"start":4,"end":12,"ntokens":2}]},"source":"documents_with_infrequent_words <- function(documents) {\n  split <- documents %>%\n    mutate(word = str_split(text, \" \")) %>%\n    unnest()\n  freq <- split %>% count(word)\n  unique_words <- freq %>% filter(n == 1)\n  split %>% \n    filter(word %in% unique_words$word) %>%\n    pull(id) %>%\n    unique()\n}","author":"will","implementation":"","ntokens":95,"category":"Strings","language_name":"R - Tidyverse","task_name":"Documents with infrequent words","token_zscore":-0.841854706,"plan_overlap":0},{"task":"process_tweets","language":"sql","plan":{"lowercase":[{"line":0,"start":7,"end":18,"ntokens":5}],"select":[{"line":0,"start":19,"end":30,"ntokens":5},{"line":0,"start":0,"end":6,"ntokens":2}],"iter":[{"line":1,"start":0,"end":9,"ntokens":3}],"filter":[{"line":2,"start":0,"end":46,"ntokens":15}]},"source":"SELECT LOWER(body) as body, ts\nFROM data\nWHERE language = \"en\" and is_retweet = \"false\"","author":"scott","implementation":"","ntokens":30,"category":"Strings","language_name":"SQL - SQLite","task_name":"Filter and clean tweets","token_zscore":-1.5626311467,"plan_overlap":1},{"task":"process_tweets","language":"python-imperative","plan":{"iter":[{"line":2,"start":2,"end":20,"ntokens":8},{"line":1,"start":2,"end":13,"ntokens":6},{"line":9,"start":2,"end":15,"ntokens":3}],"filter":[{"line":3,"start":4,"end":37,"ntokens":13},{"line":4,"start":8,"end":40,"ntokens":10}],"lowercase":[{"line":6,"start":16,"end":38,"ntokens":9}],"select":[{"line":5,"start":6,"end":21,"ntokens":4},{"line":6,"start":8,"end":15,"ntokens":3},{"line":7,"start":8,"end":25,"ntokens":7},{"line":8,"start":6,"end":8,"ntokens":1}]},"source":"def process_tweets(data):\n  result = []\n  for value in data:\n    if (value[\"language\"] == \"en\" and\n        value[\"is_retweet\"] == \"false\"):\n      result.append({\n        \"body\": value[\"body\"].lower(),\n        \"ts\": value[\"ts\"]\n      })\n  return result","author":"scott","implementation":"","ntokens":80,"category":"Strings","language_name":"Python - Imperative","task_name":"Filter and clean tweets","token_zscore":1.3673022534,"plan_overlap":4},{"task":"process_tweets","language":"python-functional","plan":{"lowercase":[{"line":2,"start":13,"end":34,"ntokens":9}],"filter":[{"line":5,"start":4,"end":36,"ntokens":12},{"line":6,"start":7,"end":37,"ntokens":9}],"select":[{"line":3,"start":5,"end":23,"ntokens":7},{"line":2,"start":4,"end":13,"ntokens":5}],"iter":[{"line":4,"start":4,"end":21,"ntokens":7},{"line":7,"start":2,"end":3,"ntokens":1},{"line":1,"start":2,"end":10,"ntokens":3}]},"source":"def process_tweets(data):\n  return [\n    {\"body\": value[\"body\"].lower(),\n     \"ts\": value[\"ts\"]}\n    for value in data\n    if value[\"language\"] == \"en\" and\n       value[\"is_retweet\"] == \"false\" \n  ]","author":"scott","implementation":"","ntokens":66,"category":"Strings","language_name":"Python - Functional","task_name":"Filter and clean tweets","token_zscore":0.5469209014,"plan_overlap":4},{"task":"process_tweets","language":"python-pandas","plan":{"iter":[{"line":1,"start":11,"end":15,"ntokens":2}],"filter":[{"line":1,"start":15,"end":16,"ntokens":1},{"line":2,"start":4,"end":29,"ntokens":11},{"line":3,"start":4,"end":33,"ntokens":9}],"lowercase":[{"line":4,"start":2,"end":54,"ntokens":22}],"select":[{"line":5,"start":2,"end":31,"ntokens":9}]},"source":"def process_tweets(data):\n  result = data[\n    (data.language == 'en') &\n    (data.is_retweet == 'false')]\n  result.body = result.body.apply(lambda s: s.lower())\n  return result[[\"body\", \"ts\"]]","author":"scott","implementation":"","ntokens":69,"category":"Strings","language_name":"Python - Pandas","task_name":"Filter and clean tweets","token_zscore":0.7227169054,"plan_overlap":0},{"task":"process_tweets","language":"r","plan":{"iter":[{"line":1,"start":2,"end":10,"ntokens":3}],"filter":[{"line":2,"start":4,"end":56,"ntokens":18}],"select":[{"line":4,"start":4,"end":20,"ntokens":6}],"lowercase":[{"line":3,"start":4,"end":36,"ntokens":12}]},"source":"process_tweets <- function(data) {\n  data %>%\n    filter(language == \"en\" & is_retweet == \"false\") %>%\n    mutate(body = tolower(body)) %>%\n    select(ts, body)\n}","author":"scott","implementation":"","ntokens":54,"category":"Strings","language_name":"R - Tidyverse","task_name":"Filter and clean tweets","token_zscore":-0.1562631147,"plan_overlap":0},{"task":"process_tweets","language":"q","plan":{"lowercase":[{"line":1,"start":9,"end":15,"ntokens":3},{"line":1,"start":19,"end":20,"ntokens":2}],"select":[{"line":1,"start":15,"end":19,"ntokens":2},{"line":1,"start":20,"end":24,"ntokens":4},{"line":1,"start":2,"end":9,"ntokens":3}],"iter":[{"line":1,"start":25,"end":34,"ntokens":4}],"filter":[{"line":2,"start":2,"end":56,"ntokens":21}]},"source":"process_tweets:\n  select lower[body], ts from data \n  where (is_retweet ~\\: \"false\") and (language ~\\: \"en\")","author":"scott","implementation":"","ntokens":41,"category":"Strings","language_name":"Q - kdb+","task_name":"Filter and clean tweets","token_zscore":-0.9180457987,"plan_overlap":1},{"task":"purchased_all_food","language":"python-pandas","plan":{"iter":[{"line":2,"start":21,"end":27,"ntokens":1},{"line":3,"start":4,"end":21,"ntokens":5},{"line":6,"start":2,"end":25,"ntokens":5},{"line":6,"start":50,"end":64,"ntokens":5}],"all":[{"line":1,"start":2,"end":20,"ntokens":8},{"line":6,"start":25,"end":50,"ntokens":6}],"ordered":[{"line":2,"start":2,"end":21,"ntokens":6},{"line":4,"start":4,"end":19,"ntokens":7},{"line":5,"start":4,"end":14,"ntokens":5}]},"source":"def purchased_all_food(food, orders):\n  n_food = len(food)\n  n_unique_orders = (orders\n    .groupby('buyer')\n    .food.unique() \n    .map(len))\n  return n_unique_orders[n_unique_orders == n_food].index.values","author":"will","implementation":"","ntokens":61,"category":"First-order logic","language_name":"Python - Pandas","task_name":"People that purchased all possible items","token_zscore":-0.5179631974,"plan_overlap":3},{"task":"purchased_all_food","language":"sql","plan":{"iter":[{"line":0,"start":0,"end":21,"ntokens":5},{"line":1,"start":0,"end":14,"ntokens":5}],"ordered":[{"line":3,"start":2,"end":46,"ntokens":16},{"line":4,"start":3,"end":29,"ntokens":13}],"all":[{"line":5,"start":2,"end":29,"ntokens":12},{"line":4,"start":30,"end":31,"ntokens":2}]},"source":"SELECT DISTINCT buyer\nFROM orders o1\nWHERE \n  (SELECT COUNT(DISTINCT food) FROM orders o2 \n   WHERE o1.buyer = o2.buyer) = \n  (SELECT COUNT(*) FROM food)","author":"will","implementation":"","ntokens":58,"category":"First-order logic","language_name":"SQL - SQLite","task_name":"People that purchased all possible items","token_zscore":-0.6934023448,"plan_overlap":0},{"task":"purchased_all_food","language":"datalog","plan":{"ordered":[{"line":0,"start":0,"end":46,"ntokens":12},{"line":1,"start":0,"end":53,"ntokens":21},{"line":6,"start":2,"end":52,"ntokens":9}],"all":[{"line":5,"start":2,"end":30,"ntokens":9},{"line":7,"start":2,"end":27,"ntokens":3}],"iter":[{"line":4,"start":2,"end":22,"ntokens":11},{"line":3,"start":19,"end":24,"ntokens":1}]},"source":".decl has_purchased(Buyer:symbol, Food:number)\nhas_purchased(Buyer, Food) :- orders(Buyer, Food, _).\n\npurchased_all_food(Buyer) :-\n  orders(Buyer, _, _),\n  N_food = count : food(_, _),\n  N_unique_orders = count : has_purchased(Buyer, _),\n  N_food = N_unique_orders.","author":"will","implementation":"","ntokens":72,"category":"First-order logic","language_name":"Datalog - Souffle","task_name":"People that purchased all possible items","token_zscore":0.1253136768,"plan_overlap":2},{"task":"purchased_all_food","language":"q","plan":{"iter":[{"line":3,"start":45,"end":56,"ntokens":4}],"ordered":[{"line":0,"start":0,"end":29,"ntokens":9}],"all":[{"line":3,"start":3,"end":44,"ntokens":17},{"line":1,"start":0,"end":18,"ntokens":7}]},"source":"buyers: `buyer xgroup orders;\ntotal: count food;\npurchased_all_food:\n  (where {(count distinct x[`food]) = total} each buyers) `buyer","author":"will","implementation":"","ntokens":47,"category":"First-order logic","language_name":"Q - kdb+","task_name":"People that purchased all possible items","token_zscore":-1.336679219,"plan_overlap":0},{"task":"purchased_all_food","language":"python-functional","plan":{"iter":[{"line":2,"start":4,"end":54,"ntokens":19},{"line":4,"start":8,"end":13,"ntokens":1},{"line":5,"start":8,"end":27,"ntokens":7}],"all":[{"line":1,"start":4,"end":22,"ntokens":8},{"line":7,"start":43,"end":52,"ntokens":3},{"line":6,"start":8,"end":10,"ntokens":2}],"ordered":[{"line":6,"start":11,"end":54,"ntokens":17},{"line":7,"start":13,"end":42,"ntokens":12}]},"source":"def purchased_all_food(food, orders):\n    n_food = len(food)\n    buyers = set([order[\"buyer\"] for order in orders])\n    return [\n        buyer\n        for buyer in buyers\n        if len(set([order[\"food\"] for order in orders \n             if order[\"buyer\"] == buyer])) == n_food\n    ]","author":"will","implementation":"","ntokens":91,"category":"First-order logic","language_name":"Python - Functional","task_name":"People that purchased all possible items","token_zscore":1.2364282776,"plan_overlap":2},{"task":"purchased_all_food","language":"python-imperative","plan":{"all":[{"line":1,"start":2,"end":20,"ntokens":8},{"line":8,"start":4,"end":29,"ntokens":11}],"ordered":[{"line":2,"start":2,"end":34,"ntokens":8},{"line":3,"start":2,"end":22,"ntokens":8},{"line":4,"start":4,"end":18,"ntokens":3},{"line":4,"start":32,"end":52,"ntokens":8},{"line":7,"start":13,"end":45,"ntokens":10}],"iter":[{"line":4,"start":18,"end":32,"ntokens":4},{"line":6,"start":2,"end":13,"ntokens":6},{"line":7,"start":2,"end":12,"ntokens":5},{"line":7,"start":20,"end":45,"ntokens":8},{"line":9,"start":6,"end":26,"ntokens":6},{"line":10,"start":2,"end":15,"ntokens":3}]},"source":"def purchased_all_food(food, orders):\n  n_food = len(food)\n  unique_orders = defaultdict(set)\n  for order in orders:\n    unique_orders[order[\"buyer\"]].add(order[\"food\"])\n      \n  buyers = []\n  for buyer, orders in unique_orders.items():\n    if len(orders) == n_food:\n      buyers.append(buyer)\n  return buyers","author":"will","implementation":"","ntokens":98,"category":"First-order logic","language_name":"Python - Imperative","task_name":"People that purchased all possible items","token_zscore":1.6457862884,"plan_overlap":3},{"task":"purchased_all_food","language":"r","plan":{"iter":[{"line":2,"start":2,"end":12,"ntokens":3},{"line":3,"start":4,"end":23,"ntokens":6},{"line":7,"start":4,"end":14,"ntokens":4}],"ordered":[{"line":4,"start":4,"end":22,"ntokens":6}],"all":[{"line":5,"start":4,"end":15,"ntokens":4},{"line":6,"start":4,"end":27,"ntokens":10},{"line":1,"start":2,"end":23,"ntokens":9}]},"source":"purchased_all_food <- function(food, orders) {\n  n_food <- count(food)    \n  orders %>%\n    group_by(buyer) %>%\n    distinct(food) %>%\n    count() %>%\n    filter(n == n_food) %>%\n    pull(buyer)\n}","author":"will","implementation":"","ntokens":62,"category":"First-order logic","language_name":"R - Tidyverse","task_name":"People that purchased all possible items","token_zscore":-0.4594834815,"plan_overlap":3},{"task":"reachable","language":"sql","plan":{"step":[{"line":2,"start":0,"end":43,"ntokens":10},{"line":4,"start":0,"end":33,"ntokens":10},{"line":5,"start":2,"end":41,"ntokens":1},{"line":6,"start":2,"end":30,"ntokens":9}],"source":[{"line":9,"start":14,"end":37,"ntokens":0},{"line":11,"start":0,"end":37,"ntokens":15}],"edge_sequence":[{"line":4,"start":2,"end":34,"ntokens":9},{"line":7,"start":2,"end":41,"ntokens":15}],"edge_match":[{"line":8,"start":2,"end":30,"ntokens":11}],"vertices":[{"line":6,"start":2,"end":33,"ntokens":9},{"line":1,"start":0,"end":23,"ntokens":7},{"line":2,"start":2,"end":34,"ntokens":9},{"line":3,"start":2,"end":7,"ntokens":1},{"line":5,"start":2,"end":7,"ntokens":1},{"line":6,"start":2,"end":8,"ntokens":2},{"line":5,"start":2,"end":7,"ntokens":1},{"line":6,"start":2,"end":33,"ntokens":9},{"line":5,"start":2,"end":7,"ntokens":1},{"line":10,"start":0,"end":33,"ntokens":13}]},"source":"WITH RECURSIVE\nclosure(source, target) AS (\n  SELECT source, source FROM graph\n  UNION\n  SELECT source, target FROM graph\n  UNION\n  SELECT edge.source, path.target\n  FROM closure as path JOIN graph as edge\n  ON edge.target = path.source\n)\nSELECT S.target FROM closure as S\nJOIN query ON S.source = query.source","author":"scott","implementation":"","ntokens":104,"category":"Graphs","language_name":"SQL - SQLite","task_name":"Reflexive-transitive closure","token_zscore":-0.902628546,"plan_overlap":5},{"task":"reachable","language":"python-imperative","plan":{"graph":[{"line":1,"start":2,"end":36,"ntokens":8},{"line":2,"start":2,"end":20,"ntokens":8},{"line":3,"start":4,"end":57,"ntokens":13}],"edge_match":[{"line":13,"start":4,"end":44,"ntokens":11},{"line":14,"start":6,"end":28,"ntokens":6}],"edge_sequence":[{"line":13,"start":20,"end":34,"ntokens":2}],"vertices":[{"line":7,"start":2,"end":26,"ntokens":8},{"line":6,"start":2,"end":17,"ntokens":7},{"line":9,"start":2,"end":26,"ntokens":11},{"line":15,"start":4,"end":24,"ntokens":6},{"line":10,"start":4,"end":28,"ntokens":9},{"line":11,"start":4,"end":26,"ntokens":8},{"line":12,"start":6,"end":14,"ntokens":1}],"source":[{"line":7,"start":18,"end":24,"ntokens":2},{"line":4,"start":2,"end":29,"ntokens":11}]},"source":"def reachable(graph, query):\n  adjacency_list = defaultdict(list)\n  for edge in graph:\n    adjacency_list[edge[\"source\"]].append(edge[\"target\"])\n  source = query[0][\"source\"]\n\n  visited = set()\n  to_visit = set([source])\n    \n  while len(to_visit) > 0:\n    current = to_visit.pop()\n    if current in visited:\n      continue\n    for neighbor in adjacency_list[current]:\n      to_visit.add(neighbor)\n    visited.add(current)\n            \n  return list(visited)","author":"scott","implementation":"","ntokens":139,"category":"Graphs","language_name":"Python - Imperative","task_name":"Reflexive-transitive closure","token_zscore":0.8331955809,"plan_overlap":4},{"task":"reachable","language":"python-functional","plan":{"edge_match":[{"line":6,"start":6,"end":33,"ntokens":10}],"edge_sequence":[{"line":5,"start":6,"end":23,"ntokens":7}],"vertices":[{"line":10,"start":2,"end":16,"ntokens":10},{"line":11,"start":4,"end":15,"ntokens":8},{"line":12,"start":4,"end":43,"ntokens":21},{"line":15,"start":14,"end":22,"ntokens":4},{"line":8,"start":4,"end":34,"ntokens":8},{"line":3,"start":6,"end":20,"ntokens":4},{"line":4,"start":6,"end":27,"ntokens":7},{"line":2,"start":4,"end":20,"ntokens":6}],"source":[{"line":14,"start":2,"end":29,"ntokens":11},{"line":15,"start":24,"end":37,"ntokens":4}]},"source":"def reachable(graph, query):\n  def step(visited):\n    frontier = set([\n      edge[\"target\"]\n      for vertex in visited\n      for edge in graph\n      if vertex == edge[\"source\"]\n    ])\n    return frontier.union(visited)\n\n  def fix(f, x):\n    next = f(x)\n    return x if next == x else fix(f, next)\n\n  source = query[0][\"source\"]\n  return list(fix(step, set([source])))","author":"scott","implementation":"","ntokens":136,"category":"Graphs","language_name":"Python - Functional","task_name":"Reflexive-transitive closure","token_zscore":0.6844106557,"plan_overlap":3},{"task":"reachable","language":"datalog","plan":{"graph":[],"source":[{"line":3,"start":0,"end":35,"ntokens":12},{"line":4,"start":0,"end":47,"ntokens":21}],"vertices":[{"line":4,"start":44,"end":45,"ntokens":1},{"line":0,"start":11,"end":31,"ntokens":1},{"line":4,"start":44,"end":45,"ntokens":1},{"line":1,"start":0,"end":26,"ntokens":18},{"line":2,"start":0,"end":38,"ntokens":27},{"line":4,"start":44,"end":45,"ntokens":1},{"line":4,"start":10,"end":11,"ntokens":1}],"edge_match":[{"line":2,"start":23,"end":24,"ntokens":1},{"line":2,"start":32,"end":33,"ntokens":1}],"edge_sequence":[{"line":1,"start":14,"end":25,"ntokens":8},{"line":2,"start":14,"end":37,"ntokens":16}]},"source":".decl path(x: symbol, y: symbol)\npath(x, y) :- graph(x, y).\npath(x, y) :- graph(x, z), path(z, y).\nreachable(source) :- query(source).\nreachable(x) :- query(source), path(source, x).","author":"scott","implementation":"","ntokens":92,"category":"Graphs","language_name":"Datalog - Souffle","task_name":"Reflexive-transitive closure","token_zscore":-1.4977682466,"plan_overlap":4},{"task":"reachable","language":"q","plan":{"graph":[{"line":0,"start":0,"end":27,"ntokens":12},{"line":1,"start":0,"end":51,"ntokens":18},{"line":2,"start":0,"end":31,"ntokens":11},{"line":3,"start":0,"end":12,"ntokens":5},{"line":4,"start":2,"end":66,"ntokens":30}],"source":[{"line":6,"start":0,"end":48,"ntokens":19},{"line":7,"start":0,"end":49,"ntokens":14}],"edge_sequence":[{"line":5,"start":0,"end":62,"ntokens":30}],"vertices":[{"line":5,"start":0,"end":62,"ntokens":30}],"edge_match":[{"line":5,"start":0,"end":62,"ntokens":30}]},"source":"graph: (first') each graph;\nnodes: asc distinct graph[`source], graph[`target];\nadj_list: `source xgroup graph;\nadj_matrix: \n  {in[;x] each nodes} each nodes ,' (adj_list each nodes) `target;\niterated_matrix: last ({x | any each (x *\\: x)} \\) adj_matrix;\nquery_idx: nodes ? (first first query[`source]);\nreachable: nodes where iterated_matrix[query_idx]","author":"scott","implementation":"","ntokens":140,"category":"Graphs","language_name":"Q - kdb+","task_name":"Reflexive-transitive closure","token_zscore":0.882790556,"plan_overlap":3},{"task":"rolling_average","language":"sql","plan":{"windows":[{"line":2,"start":0,"end":16,"ntokens":7},{"line":0,"start":0,"end":6,"ntokens":1},{"line":1,"start":0,"end":21,"ntokens":8}],"group":[{"line":3,"start":0,"end":18,"ntokens":7},{"line":4,"start":0,"end":29,"ntokens":13},{"line":5,"start":3,"end":28,"ntokens":13},{"line":6,"start":0,"end":17,"ntokens":7}],"filter":[{"line":1,"start":23,"end":46,"ntokens":10}]},"source":"SELECT\nend.time as end_time,  AVG(other.x) as average\nFROM data as end\nJOIN data as other\nON other.time <= end.time and\n   other.time > end.time - 7\nGROUP BY end.time","author":"scott","implementation":"","ntokens":67,"category":"Time Series","language_name":"SQL - SQLite","task_name":"Rolling average","token_zscore":-1.1851343832,"plan_overlap":1},{"task":"rolling_average","language":"python-imperative","plan":{"windows":[{"line":3,"start":2,"end":34,"ntokens":14},{"line":2,"start":2,"end":13,"ntokens":6},{"line":10,"start":4,"end":18,"ntokens":4},{"line":11,"start":6,"end":23,"ntokens":6},{"line":14,"start":2,"end":15,"ntokens":3}],"group":[{"line":6,"start":4,"end":30,"ntokens":19},{"line":7,"start":6,"end":36,"ntokens":18},{"line":8,"start":8,"end":13,"ntokens":1},{"line":1,"start":2,"end":36,"ntokens":15},{"line":4,"start":4,"end":23,"ntokens":8}],"filter":[{"line":9,"start":6,"end":39,"ntokens":18},{"line":5,"start":4,"end":25,"ntokens":11},{"line":12,"start":7,"end":31,"ntokens":9}]},"source":"def rolling_average(data):\n  data.sort(key=lambda v: v[\"time\"])\n  result = []\n  for i, value in enumerate(data):\n    end = value[\"time\"]\n    total, count = 0.0, 0\n    for j in range(i, -1, -1):\n      if data[j][\"time\"] <= end - 7:\n        break\n      total += data[j][\"x\"]; count += 1\n    result.append(\n      {\"end_time\": end,\n       \"average\": total \/ count}\n    )\n  return result","author":"scott","implementation":"","ntokens":154,"category":"Time Series","language_name":"Python - Imperative","task_name":"Rolling average","token_zscore":1.6341892081,"plan_overlap":3},{"task":"rolling_average","language":"python-functional","plan":{"filter":[{"line":3,"start":5,"end":34,"ntokens":14}],"windows":[{"line":4,"start":4,"end":17,"ntokens":7},{"line":1,"start":2,"end":10,"ntokens":3},{"line":2,"start":4,"end":27,"ntokens":9}],"group":[{"line":6,"start":7,"end":27,"ntokens":12},{"line":7,"start":14,"end":43,"ntokens":15},{"line":8,"start":17,"end":42,"ntokens":16},{"line":5,"start":8,"end":10,"ntokens":2}]},"source":"def rolling_average(data):\n  return [\n    {\"end_time\": x[\"time\"],\n     \"average\": sum(vs) \/ len(vs)}\n    for x in data\n    for vs in [\n      [y[\"x\"] for y in data\n              if y[\"time\"] <= x[\"time\"] and\n                 y[\"time\"] > x[\"time\"] - 7]\n    ]\n  ]","author":"scott","implementation":"","ntokens":103,"category":"Time Series","language_name":"Python - Functional","task_name":"Rolling average","token_zscore":-0.0185177247,"plan_overlap":1},{"task":"rolling_average","language":"python-pandas","plan":{"filter":[{"line":5,"start":36,"end":42,"ntokens":3},{"line":9,"start":5,"end":37,"ntokens":11}],"group":[{"line":5,"start":15,"end":35,"ntokens":7},{"line":3,"start":2,"end":47,"ntokens":20}],"windows":[{"line":4,"start":2,"end":52,"ntokens":16},{"line":1,"start":2,"end":17,"ntokens":9},{"line":7,"start":2,"end":32,"ntokens":8},{"line":8,"start":4,"end":58,"ntokens":17}]},"source":"def rolling_average(data):\n  d = data.copy()\n\n  data.time = pd.to_datetime(data.time * 10**9)\n  data = (data.sort_values('time').set_index('time')\n              .rolling(window='7s').mean())\n\n  return pd.DataFrame.from_dict(\n    {'end_time': d.sort_values('time').reset_index().time,\n     'average': data.reset_index().x}\n  )","author":"scott","implementation":"","ntokens":108,"category":"Time Series","language_name":"Python - Pandas","task_name":"Rolling average","token_zscore":0.1435123667,"plan_overlap":2},{"task":"rolling_average","language":"datalog","plan":{"group":[{"line":0,"start":0,"end":44,"ntokens":14},{"line":1,"start":0,"end":22,"ntokens":9},{"line":2,"start":2,"end":32,"ntokens":16},{"line":3,"start":2,"end":34,"ntokens":1},{"line":6,"start":31,"end":50,"ntokens":8},{"line":7,"start":31,"end":50,"ntokens":8}],"filter":[{"line":6,"start":2,"end":15,"ntokens":1},{"line":7,"start":6,"end":15,"ntokens":1},{"line":8,"start":0,"end":31,"ntokens":9},{"line":9,"start":2,"end":44,"ntokens":13},{"line":7,"start":52,"end":59,"ntokens":1}],"windows":[{"line":5,"start":30,"end":47,"ntokens":8},{"line":9,"start":2,"end":17,"ntokens":4},{"line":4,"start":0,"end":54,"ntokens":20},{"line":5,"start":0,"end":26,"ntokens":11},{"line":6,"start":19,"end":29,"ntokens":8},{"line":7,"start":19,"end":29,"ntokens":8}]},"source":".decl window(end_time: number, time: number)\nwindow(end_time, t) :-\n  data(end_time, _), data(t, _),\n  t <= end_time, t > end_time - 7.\n.decl bucket(end_time: number, total: float, n: float)\nbucket(end_time, total, n) :- data(end_time, _),\n  total = sum v : {data(t, v), window(end_time, t)},\n      n = sum z : {data(t, _), window(end_time, t), z = 1.0}.\nrolling_average(end_time, v) :-\n  bucket(end_time, total, n), v = total \/ n.","author":"scott","implementation":"","ntokens":139,"category":"Time Series","language_name":"Datalog - Souffle","task_name":"Rolling average","token_zscore":1.1480989337,"plan_overlap":3},{"task":"rolling_average","language":"r","plan":{"group":[{"line":3,"start":59,"end":72,"ntokens":7},{"line":3,"start":10,"end":47,"ntokens":12}],"filter":[{"line":3,"start":48,"end":59,"ntokens":7},{"line":3,"start":2,"end":10,"ntokens":5},{"line":4,"start":35,"end":49,"ntokens":6},{"line":4,"start":72,"end":79,"ntokens":2}]},"source":"library(slider)\nrolling_average <- function(data) {\n  data <- arrange(data, time)\n  avgs <- unlist(slide_index(data$x, data$time, ~ mean(.x), .before = 6))\n  data %>% mutate(end_time = time, average = avgs) %>% select(end_time, average)\n}","author":"scott","implementation":"","ntokens":84,"category":"Time Series","language_name":"R - Tidyverse","task_name":"Rolling average","token_zscore":-0.6342320723,"plan_overlap":1},{"task":"rolling_average","language":"q","plan":{"filter":[{"line":1,"start":15,"end":21,"ntokens":5},{"line":3,"start":25,"end":48,"ntokens":10},{"line":1,"start":8,"end":15,"ntokens":3}],"group":[{"line":1,"start":22,"end":61,"ntokens":21}],"windows":[{"line":3,"start":49,"end":58,"ntokens":3},{"line":3,"start":2,"end":23,"ntokens":8}]},"source":"get_avg: \n  {[t] (select avg(x) from data where time within (t - 6; t)) `x};\nrolling_average: \n  select end_time: time, average: get_avg'[time] from data","author":"scott","implementation":"","ntokens":70,"category":"Time Series","language_name":"Q - kdb+","task_name":"Rolling average","token_zscore":-1.0879163283,"plan_overlap":2},{"task":"row_per_child","language":"python-pandas","plan":{"each-family":[{"line":2,"start":4,"end":12,"ntokens":2}],"child-ID":[{"line":7,"start":2,"end":48,"ntokens":23}],"family-ID":[{"line":5,"start":4,"end":14,"ntokens":4}],"each-child":[{"line":6,"start":4,"end":13,"ntokens":4},{"line":4,"start":4,"end":17,"ntokens":5},{"line":1,"start":7,"end":23,"ntokens":4}],"dob-height":[{"line":3,"start":4,"end":32,"ntokens":10}]},"source":"def row_per_child(families):\n  df = pd.wide_to_long(\n    families, \n    stubnames=['dob', 'height'], \n    sep=\"_child\", \n    i='family', \n    j='child').reset_index()\n  df.child = df.child.map(lambda c: f'child{c}')\n  return df","author":"will","implementation":"","ntokens":80,"category":"Joins","language_name":"Python - Pandas","task_name":"Row per family to row per child","token_zscore":-0.5085019875,"plan_overlap":3},{"task":"row_per_child","language":"sql","plan":{"child-ID":[{"line":2,"start":2,"end":30,"ntokens":10}],"dob-height":[{"line":3,"start":2,"end":14,"ntokens":5},{"line":4,"start":4,"end":27,"ntokens":8},{"line":5,"start":4,"end":27,"ntokens":8},{"line":6,"start":4,"end":27,"ntokens":8},{"line":7,"start":3,"end":15,"ntokens":7},{"line":8,"start":2,"end":14,"ntokens":5},{"line":9,"start":4,"end":30,"ntokens":8},{"line":10,"start":4,"end":30,"ntokens":8},{"line":11,"start":4,"end":30,"ntokens":8},{"line":12,"start":3,"end":17,"ntokens":6}],"each-family":[{"line":13,"start":0,"end":5,"ntokens":2},{"line":14,"start":2,"end":10,"ntokens":1}],"each-child":[{"line":15,"start":2,"end":12,"ntokens":3},{"line":16,"start":2,"end":43,"ntokens":20}],"family-ID":[{"line":1,"start":2,"end":8,"ntokens":2}]},"source":"SELECT \n  family,\n  ('child' || child) AS child,\n  (CASE child \n    WHEN 1 THEN dob_child1 \n    WHEN 2 THEN dob_child2 \n    WHEN 3 THEN dob_child3 \n   END) AS dob,\n  (CASE child \n    WHEN 1 THEN height_child1 \n    WHEN 2 THEN height_child2 \n    WHEN 3 THEN height_child3 \n   END) AS height\nFROM \n  families\n  CROSS JOIN\n  (SELECT 1 as child UNION VALUES (2), (3))","author":"will","implementation":"","ntokens":126,"category":"Joins","language_name":"SQL - SQLite","task_name":"Row per family to row per child","token_zscore":1.2333877996,"plan_overlap":0},{"task":"row_per_child","language":"datalog","plan":{"each-family":[{"line":1,"start":2,"end":11,"ntokens":3},{"line":1,"start":42,"end":43,"ntokens":1},{"line":3,"start":2,"end":11,"ntokens":3},{"line":3,"start":42,"end":43,"ntokens":1},{"line":5,"start":2,"end":11,"ntokens":3},{"line":5,"start":42,"end":43,"ntokens":1}],"each-child":[{"line":0,"start":0,"end":47,"ntokens":17},{"line":2,"start":0,"end":47,"ntokens":17},{"line":4,"start":0,"end":47,"ntokens":17}],"family-ID":[{"line":1,"start":22,"end":28,"ntokens":1},{"line":3,"start":22,"end":28,"ntokens":1},{"line":5,"start":22,"end":28,"ntokens":1}],"child-ID":[{"line":0,"start":14,"end":22,"ntokens":1},{"line":2,"start":14,"end":22,"ntokens":1},{"line":4,"start":14,"end":22,"ntokens":1}],"dob-height":[{"line":1,"start":11,"end":14,"ntokens":1},{"line":1,"start":30,"end":36,"ntokens":1},{"line":3,"start":14,"end":17,"ntokens":1},{"line":3,"start":33,"end":39,"ntokens":1},{"line":5,"start":17,"end":20,"ntokens":1},{"line":5,"start":36,"end":42,"ntokens":1}]},"source":"row_per_child(\"child1\", dob, family, height) :-\n  families(dob, _, _, family, height, _, _).\nrow_per_child(\"child2\", dob, family, height) :-\n  families(_, dob, _, family, _, height, _).\nrow_per_child(\"child3\", dob, family, height) :-\n  families(_, _, dob, family, _, _, height).","author":"will","implementation":"","ntokens":123,"category":"Joins","language_name":"Datalog - Souffle","task_name":"Row per family to row per child","token_zscore":1.1197862917,"plan_overlap":10},{"task":"row_per_child","language":"q","plan":{"each-family":[{"line":1,"start":8,"end":28,"ntokens":13},{"line":2,"start":63,"end":64,"ntokens":2}],"each-child":[{"line":5,"start":15,"end":51,"ntokens":19},{"line":0,"start":0,"end":20,"ntokens":9},{"line":3,"start":66,"end":67,"ntokens":1}],"family-ID":[{"line":2,"start":5,"end":13,"ntokens":3}],"dob-height":[{"line":2,"start":14,"end":62,"ntokens":17}],"child-ID":[{"line":3,"start":2,"end":66,"ntokens":24}]},"source":"child_rows: {[child] \n  rows: ?[families; (); 0b; `family`dob`height ! \n    (`family; `$(\"dob_child\",child); `$(\"height_child\", child))];\n  update child: (count families)#enlist (\"child\", child) from rows}\n      \nrow_per_child: (child_rows each (\"1\"; \"2\"; \"3\")) ,\/;","author":"will","implementation":"","ntokens":104,"category":"Joins","language_name":"Q - kdb+","task_name":"Row per family to row per child","token_zscore":0.4003100753,"plan_overlap":6},{"task":"row_per_child","language":"python-functional","plan":{"each-family":[{"line":6,"start":4,"end":26,"ntokens":8}],"each-child":[{"line":7,"start":4,"end":22,"ntokens":15}],"family-ID":[{"line":2,"start":5,"end":32,"ntokens":8}],"child-ID":[{"line":3,"start":5,"end":26,"ntokens":9}],"dob-height":[{"line":4,"start":5,"end":36,"ntokens":12},{"line":5,"start":5,"end":41,"ntokens":11}]},"source":"def row_per_child(families):\n  return [\n    {'family': family['family'],\n     'child': f'child{i}',\n     'dob': family[f'dob_child{i}'],\n     'height': family[f'height_child{i}']}\n    for family in families    \n    for i in [1, 2, 3]\n  ]","author":"will","implementation":"","ntokens":83,"category":"Joins","language_name":"Python - Functional","task_name":"Row per family to row per child","token_zscore":-0.3949004797,"plan_overlap":0},{"task":"row_per_child","language":"python-imperative","plan":{"each-family":[{"line":3,"start":2,"end":25,"ntokens":8}],"family-ID":[{"line":6,"start":8,"end":35,"ntokens":8}],"each-child":[{"line":4,"start":4,"end":23,"ntokens":16},{"line":5,"start":6,"end":23,"ntokens":4},{"line":10,"start":6,"end":8,"ntokens":1}],"child-ID":[{"line":7,"start":8,"end":29,"ntokens":9}],"dob-height":[{"line":8,"start":8,"end":39,"ntokens":12},{"line":9,"start":8,"end":44,"ntokens":11}]},"source":"\ndef row_per_child(families):\n  children = []\n  for family in families:\n    for i in [1, 2, 3]:\n      children.append({\n        'family': family['family'],\n        'child': f'child{i}',\n        'dob': family[f'dob_child{i}'],\n        'height': family[f'height_child{i}']\n      })\n  return children\n","author":"will","implementation":"","ntokens":95,"category":"Joins","language_name":"Python - Imperative","task_name":"Row per family to row per child","token_zscore":0.0595055517,"plan_overlap":3},{"task":"row_per_child","language":"r","plan":{"each-family":[{"line":1,"start":2,"end":14,"ntokens":3}],"family-ID":[{"line":3,"start":6,"end":13,"ntokens":3}],"each-child":[{"line":4,"start":6,"end":38,"ntokens":11},{"line":5,"start":6,"end":22,"ntokens":6}],"child-ID":[{"line":2,"start":4,"end":17,"ntokens":2},{"line":6,"start":4,"end":5,"ntokens":1}],"dob-height":[{"line":2,"start":4,"end":17,"ntokens":2},{"line":6,"start":4,"end":5,"ntokens":1}]},"source":"row_per_child <- function(families) {\n  families %>%\n    pivot_longer(\n      !family,\n      names_to = c(\".value\", \"child\"),\n      names_sep = \"_\",\n    )\n}","author":"will","implementation":"","ntokens":43,"category":"Joins","language_name":"R - Tidyverse","task_name":"Row per family to row per child","token_zscore":-1.9095872511,"plan_overlap":5},{"task":"scc","language":"sql","plan":{"vertices":[{"line":1,"start":0,"end":23,"ntokens":7}],"edge_match":[{"line":6,"start":2,"end":30,"ntokens":11}],"edge_sequence":[{"line":4,"start":2,"end":33,"ntokens":9},{"line":5,"start":2,"end":41,"ntokens":15}],"source<->target":[{"line":11,"start":2,"end":62,"ntokens":23},{"line":10,"start":2,"end":44,"ntokens":15},{"line":14,"start":0,"end":33,"ntokens":15},{"line":8,"start":0,"end":22,"ntokens":10},{"line":9,"start":2,"end":33,"ntokens":9},{"line":13,"start":0,"end":31,"ntokens":13}],"graph":[{"line":2,"start":2,"end":43,"ntokens":11}]},"source":"WITH RECURSIVE\nclosure(source, target) AS (\n  SELECT DISTINCT source, target FROM graph\n  UNION\n  SELECT edge.source, path.target\n  FROM closure as path JOIN graph as edge\n  ON edge.target = path.source\n),\ncomponent(v1, v2) AS (\n  SELECT path.source, path.target\n  FROM closure as path JOIN closure as path_\n  ON path.source = path_.target AND path.target = path_.source\n)\nSELECT S.v2 FROM component as S\nJOIN query ON S.v1 = query.source","author":"scott","implementation":"","ntokens":156,"category":"Graphs","language_name":"SQL - SQLite","task_name":"Strongly-connected components","token_zscore":-1.2652484068,"plan_overlap":0},{"task":"scc","language":"python-imperative","plan":{"graph":[{"line":2,"start":2,"end":18,"ntokens":7},{"line":5,"start":4,"end":32,"ntokens":8},{"line":6,"start":4,"end":32,"ntokens":8},{"line":3,"start":2,"end":20,"ntokens":8},{"line":4,"start":4,"end":51,"ntokens":14},{"line":18,"start":2,"end":25,"ntokens":8}],"source<->target":[{"line":19,"start":4,"end":41,"ntokens":14},{"line":20,"start":8,"end":39,"ntokens":12},{"line":16,"start":2,"end":29,"ntokens":11},{"line":17,"start":2,"end":13,"ntokens":6},{"line":22,"start":2,"end":15,"ntokens":3},{"line":21,"start":6,"end":27,"ntokens":6}],"vertices":[{"line":1,"start":2,"end":19,"ntokens":7},{"line":12,"start":8,"end":53,"ntokens":17},{"line":13,"start":12,"end":55,"ntokens":17},{"line":14,"start":10,"end":24,"ntokens":5},{"line":15,"start":10,"end":49,"ntokens":12},{"line":8,"start":2,"end":16,"ntokens":4},{"line":9,"start":4,"end":19,"ntokens":5},{"line":21,"start":9,"end":9,"ntokens":1},{"line":7,"start":0,"end":16,"ntokens":6}],"edge_sequence":[{"line":10,"start":4,"end":22,"ntokens":8},{"line":11,"start":6,"end":29,"ntokens":8}]},"source":"def scc(graph, query):\n  reachable = set()\n  vertices = set()\n  for edge in graph:\n    reachable.add((edge[\"source\"], edge[\"target\"]))\n    vertices.add(edge[\"source\"])\n    vertices.add(edge[\"target\"])\n  changed = True\n  while changed:\n    changed = False\n    for edge in graph:\n      for vertex in vertices:\n        if ((edge[\"source\"], vertex) not in reachable\n            and (edge[\"target\"], vertex) in reachable):\n          changed = True\n          reachable.add((edge[\"source\"], vertex))\n  source = query[0][\"source\"]\n  result = []\n  for vertex in vertices:\n    if ((source, vertex) in reachable and\n        (vertex, source) in reachable):\n      result.append(vertex)\n  return result","author":"scott","implementation":"","ntokens":225,"category":"Graphs","language_name":"Python - Imperative","task_name":"Strongly-connected components","token_zscore":1.2114080491,"plan_overlap":5},{"task":"scc","language":"python-functional","plan":{"source<->target":[{"line":13,"start":4,"end":31,"ntokens":11},{"line":16,"start":4,"end":46,"ntokens":20},{"line":17,"start":6,"end":65,"ntokens":26}],"edge_sequence":[{"line":4,"start":12,"end":44,"ntokens":12},{"line":5,"start":12,"end":29,"ntokens":7}],"edge_match":[{"line":6,"start":12,"end":39,"ntokens":10}],"vertices":[{"line":1,"start":4,"end":23,"ntokens":7},{"line":2,"start":8,"end":20,"ntokens":4},{"line":3,"start":12,"end":36,"ntokens":8},{"line":9,"start":4,"end":18,"ntokens":10},{"line":10,"start":8,"end":19,"ntokens":8},{"line":11,"start":8,"end":47,"ntokens":21},{"line":15,"start":4,"end":31,"ntokens":11},{"line":7,"start":8,"end":26,"ntokens":6}],"graph":[{"line":14,"start":4,"end":68,"ntokens":25}]},"source":"def scc(graph, query):\n    def step(relation):\n        return set([\n            (source, edge[\"target\"])\n            for (source, target) in relation\n            for edge in graph\n            if target == edge[\"source\"]\n        ]).union(relation)\n\n    def fix(f, x):\n        next = f(x)\n        return x if next == x else fix(f, next)\n\n    source = query[0][\"source\"]\n    init = set([(edge[\"source\"], edge[\"target\"]) for edge in graph])\n    reachable = fix(step, init)\n    return list(set([v for (_, v) in reachable\n      if (v, source) in reachable and (source, v) in reachable]))","author":"scott","implementation":"","ntokens":211,"category":"Graphs","language_name":"Python - Functional","task_name":"Strongly-connected components","token_zscore":0.7088980435,"plan_overlap":5},{"task":"scc","language":"datalog","plan":{"edge_match":[{"line":8,"start":31,"end":32,"ntokens":0},{"line":5,"start":22,"end":22,"ntokens":1},{"line":5,"start":31,"end":31,"ntokens":1},{"line":5,"start":22,"end":23,"ntokens":1},{"line":5,"start":31,"end":32,"ntokens":1}],"edge_sequence":[{"line":4,"start":14,"end":25,"ntokens":8},{"line":5,"start":13,"end":36,"ntokens":16}],"graph":[{"line":10,"start":0,"end":26,"ntokens":0},{"line":7,"start":0,"end":26,"ntokens":15},{"line":8,"start":0,"end":26,"ntokens":15},{"line":6,"start":0,"end":23,"ntokens":8}],"source<->target":[{"line":0,"start":0,"end":32,"ntokens":14},{"line":1,"start":0,"end":24,"ntokens":15},{"line":2,"start":0,"end":37,"ntokens":27},{"line":9,"start":0,"end":35,"ntokens":21}],"vertices":[{"line":3,"start":0,"end":32,"ntokens":14},{"line":4,"start":0,"end":26,"ntokens":18},{"line":5,"start":0,"end":37,"ntokens":26}]},"source":".decl scc1(x: symbol, y: symbol)\nscc1(x, x) :- vertex(x).\nscc1(x, y) :- path(x, y), path(y, x).\n.decl path(x: symbol, y: symbol)\npath(x, y) :- graph(x, y).\npath(x,y) :- graph(x, z), path(z, y).\n.decl vertex(x: symbol)\nvertex(x)  :- graph(x, _).\nvertex(x)  :- graph(_, x).\nscc(x) :- query(src), scc1(src, x).","author":"scott","implementation":"","ntokens":173,"category":"Graphs","language_name":"Datalog - Souffle","task_name":"Strongly-connected components","token_zscore":-0.6550576858,"plan_overlap":8},{"task":"strings_to_numbers","language":"python-pandas","plan":{"cond":[{"line":2,"start":4,"end":51,"ntokens":19}],"clean":[{"line":3,"start":15,"end":41,"ntokens":11}],"number":[{"line":3,"start":41,"end":42,"ntokens":1},{"line":3,"start":4,"end":15,"ntokens":5}],"iter":[{"line":4,"start":9,"end":48,"ntokens":15}]},"source":"def strings_to_numbers(numbers):\n  def convert(row):\n    sep = \",\" if row.format == 'comma_sep' else \"_\"\n    return int(row.value.replace(sep, \"\"))\n  return numbers.apply(convert, axis=1).tolist()","author":"will","implementation":"","ntokens":69,"category":"Strings","language_name":"Python - Pandas","task_name":"Convert strings with different formats to numbers","token_zscore":-0.0782192712,"plan_overlap":1},{"task":"strings_to_numbers","language":"sql","plan":{"cond":[{"line":1,"start":8,"end":19,"ntokens":0},{"line":4,"start":6,"end":18,"ntokens":4},{"line":5,"start":8,"end":34,"ntokens":8},{"line":6,"start":8,"end":34,"ntokens":8},{"line":7,"start":6,"end":9,"ntokens":2}],"clean":[{"line":2,"start":26,"end":49,"ntokens":0},{"line":3,"start":26,"end":49,"ntokens":0},{"line":2,"start":4,"end":12,"ntokens":2},{"line":3,"start":6,"end":13,"ntokens":2},{"line":7,"start":9,"end":14,"ntokens":3}],"number":[{"line":1,"start":2,"end":7,"ntokens":2},{"line":8,"start":4,"end":15,"ntokens":4}],"iter":[{"line":9,"start":0,"end":12,"ntokens":3}]},"source":"SELECT \n  CAST(\n    REPLACE(\n      value, \n      CASE format \n        WHEN \"comma_sep\" THEN \",\" \n        WHEN \"under_sep\" THEN \"_\" \n      END, \"\")\n    AS integer)\nFROM numbers","author":"will","implementation":"","ntokens":47,"category":"Strings","language_name":"SQL - SQLite","task_name":"Convert strings with different formats to numbers","token_zscore":-0.8310797564,"plan_overlap":3},{"task":"strings_to_numbers","language":"datalog","plan":{"number":[{"line":13,"start":2,"end":22,"ntokens":6}],"cond":[{"line":6,"start":2,"end":37,"ntokens":1},{"line":7,"start":3,"end":38,"ntokens":1},{"line":1,"start":0,"end":28,"ntokens":16}],"clean":[{"line":2,"start":0,"end":32,"ntokens":17},{"line":3,"start":2,"end":34,"ntokens":14},{"line":4,"start":2,"end":19,"ntokens":6},{"line":5,"start":2,"end":26,"ntokens":12},{"line":8,"start":2,"end":33,"ntokens":1},{"line":9,"start":3,"end":44,"ntokens":9},{"line":12,"start":2,"end":40,"ntokens":17},{"line":0,"start":0,"end":62,"ntokens":23}],"iter":[{"line":1,"start":29,"end":50,"ntokens":8}]},"source":".decl clean(Format:symbol, Inp:symbol, I:number, Outp:symbol) \nclean(Format, Inp, 0, \"\") :- numbers(Format, Inp).\nclean(Format, Inp, I+1, Outp) :-\n  clean(Format, Inp, I, Outp_rec),\n  I <= strlen(Inp),\n  Chr = substr(Inp, I, 1),\n  ((Format = \"comma_sep\", Sep = \",\");\n   (Format = \"under_sep\", Sep = \"_\")),\n  ((Chr  = Sep, Outp = Outp_rec);\n   (Chr != Sep, Outp = cat(Outp_rec, Chr))).\n\nstrings_to_numbers(N) :-\n  clean(Format, Inp, strlen(Inp), Outp),\n  N = to_number(Outp).","author":"will","implementation":"","ntokens":139,"category":"Strings","language_name":"Datalog - Souffle","task_name":"Convert strings with different formats to numbers","token_zscore":2.317245909,"plan_overlap":3},{"task":"strings_to_numbers","language":"q","plan":{"cond":[{"line":1,"start":2,"end":56,"ntokens":21}],"clean":[{"line":2,"start":8,"end":25,"ntokens":10}],"number":[{"line":2,"start":2,"end":7,"ntokens":4}],"iter":[{"line":5,"start":2,"end":45,"ntokens":13}]},"source":"convert: {[val; format] \n  sep: ((\"comma_sep\"; \"under_sep\") ! (\",\"; \"_\")) format;\n  \"J\" $ ssr[val; sep; \"\"]}\n  \nstrings_to_numbers:\n  convert'[numbers[`value]; numbers[`format]]","author":"will","implementation":"","ntokens":68,"category":"Strings","language_name":"Q - kdb+","task_name":"Convert strings with different formats to numbers","token_zscore":-0.1124402023,"plan_overlap":0},{"task":"strings_to_numbers","language":"python-functional","plan":{"iter":[{"line":1,"start":2,"end":10,"ntokens":3},{"line":4,"start":4,"end":30,"ntokens":7},{"line":5,"start":2,"end":3,"ntokens":1}],"number":[{"line":2,"start":4,"end":8,"ntokens":3},{"line":3,"start":55,"end":56,"ntokens":1}],"clean":[{"line":2,"start":8,"end":29,"ntokens":7},{"line":3,"start":50,"end":55,"ntokens":4}],"cond":[{"line":3,"start":6,"end":50,"ntokens":17}]},"source":"def strings_to_numbers(numbers):\n  return [\n    int(row[\"value\"].replace(\n      \",\" if row[\"format\"] == \"comma_sep\" else \"_\", \"\"))\n    for row in numbers\n  ]","author":"will","implementation":"","ntokens":52,"category":"Strings","language_name":"Python - Functional","task_name":"Convert strings with different formats to numbers","token_zscore":-0.6599751007,"plan_overlap":6},{"task":"strings_to_numbers","language":"python-imperative","plan":{"iter":[{"line":1,"start":1,"end":13,"ntokens":7},{"line":7,"start":4,"end":18,"ntokens":5},{"line":7,"start":52,"end":53,"ntokens":1},{"line":2,"start":2,"end":21,"ntokens":8}],"cond":[{"line":3,"start":4,"end":36,"ntokens":11},{"line":4,"start":6,"end":15,"ntokens":5},{"line":5,"start":4,"end":9,"ntokens":2},{"line":6,"start":6,"end":15,"ntokens":5}],"number":[{"line":7,"start":18,"end":22,"ntokens":3},{"line":7,"start":51,"end":52,"ntokens":1}],"clean":[{"line":7,"start":22,"end":51,"ntokens":12}]},"source":"def strings_to_numbers(numbers):\n  output = []\n  for row in numbers:\n    if row[\"format\"] == 'comma_sep':\n      sep = \",\"\n    else:\n      sep = \"_\"\n    output.append(int(row[\"value\"].replace(sep, \"\")))\n  return output","author":"will","implementation":"","ntokens":73,"category":"Strings","language_name":"Python - Imperative","task_name":"Convert strings with different formats to numbers","token_zscore":0.0586644534,"plan_overlap":4},{"task":"strings_to_numbers","language":"r","plan":{"cond":[{"line":3,"start":13,"end":52,"ntokens":13}],"clean":[{"line":2,"start":31,"end":47,"ntokens":2},{"line":3,"start":6,"end":13,"ntokens":3},{"line":3,"start":52,"end":57,"ntokens":3}],"number":[{"line":2,"start":20,"end":31,"ntokens":3},{"line":3,"start":57,"end":58,"ntokens":1}],"iter":[{"line":1,"start":2,"end":13,"ntokens":3},{"line":2,"start":4,"end":20,"ntokens":7},{"line":3,"start":58,"end":63,"ntokens":3},{"line":4,"start":4,"end":16,"ntokens":4}]},"source":"strings_to_numbers <- function(numbers) {\n  numbers %>%\n    mutate(output = as.numeric(str_replace_all(\n      value, ifelse(format == \"comma_sep\", \",\", \"_\"), \"\"))) %>%\n    pull(output)\n}","author":"will","implementation":"","ntokens":51,"category":"Strings","language_name":"R - Tidyverse","task_name":"Convert strings with different formats to numbers","token_zscore":-0.6941960318,"plan_overlap":6},{"task":"tom_hanks","language":"python-imperative","plan":{"director":[{"line":7,"start":10,"end":40,"ntokens":8},{"line":8,"start":4,"end":22,"ntokens":3},{"line":2,"start":2,"end":21,"ntokens":7},{"line":5,"start":6,"end":25,"ntokens":8}],"actor":[{"line":4,"start":4,"end":33,"ntokens":11},{"line":3,"start":2,"end":18,"ntokens":8}],"movies":[{"line":6,"start":8,"end":36,"ntokens":14}]},"source":"\ndef tom_hanks(actors,directors):\n  r_directors = set()\n  for a in actors:\n    if 'Tom Hanks' == a['actor']:\n      for d in directors:\n        if a['movie'] == d['movie']:\n          r_directors.add(d['director'])\n    return r_directors\n","author":"g","implementation":"","ntokens":75,"category":"Joins","language_name":"Python - Imperative","task_name":"Directors of movies Tom Hanks starred in","token_zscore":1.4808883095,"plan_overlap":2},{"task":"tom_hanks","language":"python-pandas","plan":{"director":[{"line":4,"start":2,"end":38,"ntokens":9},{"line":5,"start":4,"end":29,"ntokens":7}],"actor":[{"line":3,"start":3,"end":34,"ntokens":10}],"movies":[{"line":3,"start":36,"end":43,"ntokens":2},{"line":4,"start":19,"end":37,"ntokens":5}]},"source":"\ndef tom_hanks(actors,directors):\n  movies = list(actors.loc[\n    actors['actor'] == 'Tom Hanks', 'movie'])\n  return directors[directors['movie'].\n    isin(movies)]['director']\n","author":"g","implementation":"","ntokens":51,"category":"Joins","language_name":"Python - Pandas","task_name":"Directors of movies Tom Hanks starred in","token_zscore":0.1287728965,"plan_overlap":1},{"task":"tom_hanks","language":"r","plan":{"actor":[{"line":2,"start":4,"end":36,"ntokens":10}],"movies":[{"line":1,"start":2,"end":12,"ntokens":3}],"director":[{"line":3,"start":4,"end":43,"ntokens":12},{"line":4,"start":4,"end":18,"ntokens":4}]},"source":"tom_hanks <- function(actors, directors) {\n  actors %>%\n    filter(actor == \"Tom Hanks\") %>%\n    inner_join(directors, by = \"movie\") %>%\n    pull(director)\n}","author":"g","implementation":"","ntokens":46,"category":"Joins","language_name":"R - Tidyverse","task_name":"Directors of movies Tom Hanks starred in","token_zscore":-0.1529178146,"plan_overlap":0},{"task":"tom_hanks","language":"q","plan":{"actor":[{"line":2,"start":3,"end":30,"ntokens":8}],"director":[{"line":2,"start":32,"end":41,"ntokens":1},{"line":1,"start":3,"end":18,"ntokens":4},{"line":1,"start":31,"end":57,"ntokens":10}],"movies":[{"line":1,"start":19,"end":30,"ntokens":4},{"line":1,"start":35,"end":41,"ntokens":2}]},"source":"tom_hanks:\n  (select director from actors ij (`movie xkey directors) \n   where actor ~\\: \"Tom Hanks\") `director","author":"g","implementation":"","ntokens":35,"category":"Joins","language_name":"Q - kdb+","task_name":"Directors of movies Tom Hanks starred in","token_zscore":-0.7726373789,"plan_overlap":2},{"task":"tom_hanks","language":"sql","plan":{"director":[{"line":1,"start":0,"end":25,"ntokens":5},{"line":2,"start":0,"end":5,"ntokens":2},{"line":3,"start":2,"end":12,"ntokens":2}],"actor":[{"line":7,"start":0,"end":30,"ntokens":7},{"line":4,"start":2,"end":19,"ntokens":5}],"movies":[{"line":5,"start":2,"end":23,"ntokens":8},{"line":6,"start":2,"end":14,"ntokens":3}]},"source":"\nSELECT directors.director\nFROM \n  directors \n  INNER JOIN actors\n  ON directors.movie = \n  actors.movie\nWHERE actors.actor=\"Tom Hanks\"\n","author":"g","implementation":"","ntokens":36,"category":"Joins","language_name":"SQL - SQLite","task_name":"Directors of movies Tom Hanks starred in","token_zscore":-0.7162992367,"plan_overlap":1},{"task":"tom_hanks","language":"datalog","plan":{"director":[{"line":3,"start":2,"end":28,"ntokens":7},{"line":1,"start":10,"end":18,"ntokens":1}],"actor":[{"line":2,"start":2,"end":28,"ntokens":11}],"movies":[{"line":2,"start":21,"end":26,"ntokens":1},{"line":3,"start":21,"end":26,"ntokens":1}]},"source":"\ntom_hanks(Director):-\n  actors(\"Tom Hanks\",movie),\n  directors(Director,movie).\n","author":"g","implementation":"","ntokens":25,"category":"Joins","language_name":"Datalog - Souffle","task_name":"Directors of movies Tom Hanks starred in","token_zscore":-1.336018801,"plan_overlap":3},{"task":"tom_hanks","language":"python-functional","plan":{"director":[{"line":3,"start":15,"end":47,"ntokens":13},{"line":4,"start":2,"end":18,"ntokens":3},{"line":3,"start":2,"end":19,"ntokens":8}],"actor":[{"line":2,"start":46,"end":71,"ntokens":6},{"line":2,"start":23,"end":71,"ntokens":19}],"movies":[{"line":2,"start":12,"end":22,"ntokens":5},{"line":3,"start":52,"end":75,"ntokens":8},{"line":2,"start":2,"end":19,"ntokens":8}]},"source":"\ndef tom_hanks(actors,directors):\n  movies = [a['movie'] for a in actors if a['actor'] == 'Tom Hanks']\n  directors = [d['director'] for d in directors if d['movie'] in movies]\n  return directors\n","author":"g","implementation":"","ntokens":73,"category":"Joins","language_name":"Python - Functional","task_name":"Directors of movies Tom Hanks starred in","token_zscore":1.3682120251,"plan_overlap":3},{"task":"unique_beer_drinkers","language":"python-pandas","plan":{"iter":[{"line":1,"start":22,"end":27,"ntokens":1},{"line":2,"start":4,"end":20,"ntokens":5},{"line":1,"start":2,"end":22,"ntokens":6},{"line":11,"start":1,"end":37,"ntokens":7},{"line":12,"start":52,"end":53,"ntokens":1},{"line":13,"start":2,"end":38,"ntokens":9}],"collect":[{"line":3,"start":4,"end":27,"ntokens":11},{"line":4,"start":4,"end":18,"ntokens":4},{"line":1,"start":2,"end":22,"ntokens":6}],"compare":[{"line":6,"start":2,"end":28,"ntokens":7},{"line":7,"start":4,"end":36,"ntokens":6},{"line":8,"start":6,"end":43,"ntokens":10},{"line":9,"start":4,"end":55,"ntokens":19},{"line":12,"start":4,"end":52,"ntokens":11}]},"source":"def unique_beer_drinkers(likes):\n  likes_per_person = (likes\n    .groupby('name')\n    .beer.unique().map(set)\n    .reset_index())\n\n  def check_not_exists(row):\n    other_people = likes_per_person[\n      likes_per_person.name != row['name']]\n    return not (other_people.beer == row['beer']).any()\n  \n  unique_drinkers = likes_per_person[\n    likes_per_person.apply(check_not_exists, axis=1)]\n  return unique_drinkers.name.tolist()","author":"will","implementation":"","ntokens":113,"category":"First-order logic","language_name":"Python - Pandas","task_name":"People who like a unique set of beer","token_zscore":-0.1577771845,"plan_overlap":2},{"task":"unique_beer_drinkers","language":"datalog","plan":{"iter":[{"line":11,"start":21,"end":25,"ntokens":1},{"line":12,"start":2,"end":17,"ntokens":8}],"compare":[{"line":13,"start":2,"end":20,"ntokens":6},{"line":4,"start":0,"end":27,"ntokens":7},{"line":5,"start":0,"end":20,"ntokens":7},{"line":7,"start":2,"end":18,"ntokens":8},{"line":8,"start":2,"end":16,"ntokens":1},{"line":6,"start":2,"end":18,"ntokens":8},{"line":9,"start":2,"end":23,"ntokens":9},{"line":1,"start":0,"end":16,"ntokens":11},{"line":1,"start":30,"end":61,"ntokens":17},{"line":2,"start":0,"end":46,"ntokens":30},{"line":0,"start":0,"end":32,"ntokens":12}],"collect":[{"line":1,"start":16,"end":30,"ntokens":8},{"line":2,"start":46,"end":60,"ntokens":8}]},"source":".decl differ(a:symbol, b:symbol)\ndiffer(A, B) :- likes(Beer, A), likes(_, B), !likes(Beer, B).\ndiffer(A, B) :- likes(_, A), likes(Beer, B), !likes(Beer, A).\n\n.decl exists_same(a:symbol)\nexists_same(Name) :- \n  likes(_, Other), \n  likes(_, Name), \n  Name != Other, \n  !differ(Name, Other).\n\nunique_beer_drinkers(Name) :- \n  likes(_, Name), \n  !exists_same(Name).","author":"will","implementation":"neg_exist","ntokens":150,"category":"First-order logic","language_name":"Datalog - Souffle","task_name":"People who like a unique set of beer","token_zscore":0.7925551592,"plan_overlap":2},{"task":"unique_beer_drinkers","language":"sql","plan":{"iter":[{"line":0,"start":0,"end":23,"ntokens":7},{"line":1,"start":0,"end":13,"ntokens":5}],"compare":[{"line":2,"start":0,"end":17,"ntokens":6},{"line":23,"start":34,"end":35,"ntokens":1},{"line":3,"start":4,"end":12,"ntokens":2},{"line":4,"start":4,"end":17,"ntokens":5},{"line":5,"start":4,"end":28,"ntokens":11},{"line":6,"start":4,"end":19,"ntokens":6},{"line":7,"start":8,"end":16,"ntokens":2},{"line":8,"start":8,"end":21,"ntokens":5},{"line":9,"start":8,"end":31,"ntokens":11},{"line":10,"start":8,"end":23,"ntokens":6},{"line":14,"start":12,"end":35,"ntokens":12},{"line":15,"start":4,"end":19,"ntokens":6},{"line":19,"start":8,"end":23,"ntokens":6},{"line":20,"start":12,"end":20,"ntokens":2},{"line":21,"start":12,"end":25,"ntokens":5},{"line":22,"start":12,"end":35,"ntokens":11},{"line":23,"start":12,"end":35,"ntokens":11}],"collect":[{"line":11,"start":12,"end":20,"ntokens":2},{"line":12,"start":12,"end":25,"ntokens":5},{"line":13,"start":12,"end":35,"ntokens":11},{"line":16,"start":8,"end":16,"ntokens":2},{"line":17,"start":8,"end":21,"ntokens":5},{"line":18,"start":8,"end":31,"ntokens":11}]},"source":"SELECT DISTINCT L1.name\nFROM likes L1\nWHERE NOT EXISTS(\n    SELECT *\n    FROM likes L2\n    WHERE L1.name != L2.name\n    AND NOT EXISTS(\n        SELECT *\n        FROM likes L3\n        WHERE L3.name = L2.name\n        AND NOT EXISTS(\n            SELECT *\n            FROM likes L4\n            WHERE L4.name = L1.name\n            AND L4.beer = L3.beer))\n    AND NOT EXISTS(\n        SELECT *\n        FROM likes L5\n        WHERE L5.name = L1.name\n        AND NOT EXISTS(\n            SELECT *\n            FROM likes L6\n            WHERE L6.name = L2.name\n            AND L6.beer= L5.beer)))","author":"will","implementation":"","ntokens":176,"category":"First-order logic","language_name":"SQL - SQLite","task_name":"People who like a unique set of beer","token_zscore":1.4603562655,"plan_overlap":1},{"task":"unique_beer_drinkers","language":"q","plan":{"collect":[{"line":0,"start":0,"end":37,"ntokens":13}],"compare":[{"line":1,"start":0,"end":42,"ntokens":14},{"line":3,"start":43,"end":68,"ntokens":10}],"iter":[{"line":3,"start":3,"end":42,"ntokens":13},{"line":4,"start":2,"end":7,"ntokens":1}]},"source":"likes_per_person: `name xgroup likes;\ncounts: count each group likes_per_person;\nunique_beer_drinkers: \n  (select name from likes_per_person where beer in\\: where[counts=1])\n  `name","author":"will","implementation":"","ntokens":61,"category":"First-order logic","language_name":"Q - kdb+","task_name":"People who like a unique set of beer","token_zscore":-1.4933793971,"plan_overlap":1},{"task":"unique_beer_drinkers","language":"python-functional","plan":{"iter":[{"line":1,"start":2,"end":46,"ntokens":19},{"line":4,"start":4,"end":22,"ntokens":7},{"line":5,"start":2,"end":3,"ntokens":1},{"line":2,"start":2,"end":22,"ntokens":5},{"line":3,"start":4,"end":9,"ntokens":3},{"line":7,"start":2,"end":10,"ntokens":3},{"line":8,"start":4,"end":8,"ntokens":1},{"line":9,"start":4,"end":13,"ntokens":5},{"line":9,"start":20,"end":47,"ntokens":7},{"line":14,"start":2,"end":3,"ntokens":1}],"collect":[{"line":3,"start":10,"end":68,"ntokens":26},{"line":9,"start":13,"end":47,"ntokens":10}],"compare":[{"line":10,"start":4,"end":16,"ntokens":6},{"line":11,"start":6,"end":49,"ntokens":13},{"line":12,"start":6,"end":61,"ntokens":14},{"line":13,"start":4,"end":6,"ntokens":1}]},"source":"def unique_beer_drinkers(likes):\n  people = set([row['name'] for row in likes])\n  likes_per_person = {\n    name: set([row['beer'] for row in likes if row['name'] == name])\n    for name in people\n  }\n    \n  return [\n    name\n    for name, beers in likes_per_person.items()\n    if not any([\n      other_name != name and beers == other_beers\n      for other_name, other_beers in likes_per_person.items()\n    ])\n  ]","author":"will","implementation":"","ntokens":135,"category":"First-order logic","language_name":"Python - Functional","task_name":"People who like a unique set of beer","token_zscore":0.4072852901,"plan_overlap":2},{"task":"unique_beer_drinkers","language":"python-imperative","plan":{"collect":[{"line":1,"start":21,"end":37,"ntokens":4},{"line":3,"start":33,"end":50,"ntokens":7},{"line":6,"start":10,"end":47,"ntokens":10},{"line":18,"start":2,"end":15,"ntokens":3}],"iter":[{"line":2,"start":2,"end":19,"ntokens":8},{"line":3,"start":4,"end":33,"ntokens":7},{"line":5,"start":2,"end":13,"ntokens":6},{"line":6,"start":2,"end":9,"ntokens":5},{"line":6,"start":19,"end":47,"ntokens":8}],"compare":[{"line":7,"start":4,"end":20,"ntokens":5},{"line":8,"start":4,"end":49,"ntokens":15},{"line":9,"start":6,"end":18,"ntokens":8},{"line":10,"start":8,"end":16,"ntokens":1},{"line":12,"start":6,"end":30,"ntokens":8},{"line":13,"start":8,"end":25,"ntokens":5},{"line":14,"start":8,"end":13,"ntokens":1},{"line":15,"start":4,"end":17,"ntokens":4},{"line":16,"start":6,"end":23,"ntokens":6}]},"source":"def unique_beer_drinkers(likes):\n  likes_per_person = defaultdict(set)\n  for row in likes:\n    likes_per_person[row['name']].add(row['beer'])\n    \n  unique = []\n  for p1, p1_likes in likes_per_person.items():\n    is_unique = True\n    for p2, p2_likes in likes_per_person.items():\n      if p1 == p2:\n        continue\n        \n      if p1_likes == p2_likes:\n        is_unique = False\n        break\n    if is_unique:\n      unique.append(p1)\n      \n  return unique","author":"will","implementation":"","ntokens":131,"category":"First-order logic","language_name":"Python - Imperative","task_name":"People who like a unique set of beer","token_zscore":0.3045466584,"plan_overlap":2},{"task":"unique_beer_drinkers","language":"r","plan":{"iter":[{"line":1,"start":2,"end":11,"ntokens":3},{"line":2,"start":4,"end":22,"ntokens":6},{"line":6,"start":4,"end":14,"ntokens":4}],"collect":[{"line":3,"start":4,"end":54,"ntokens":16}],"compare":[{"line":4,"start":4,"end":54,"ntokens":12},{"line":5,"start":4,"end":37,"ntokens":10}]},"source":"unique_beer_drinkers <- function(likes) {\n  likes %>%\n    group_by(name) %>%\n    summarize(beer_set = list(sort(unique(beer)))) %>%\n    add_count(beer_set, name = 'num_people_likes') %>%\n    filter(num_people_likes == 1) %>%\n    pull(name)\n}","author":"will","implementation":"","ntokens":68,"category":"First-order logic","language_name":"R - Tidyverse","task_name":"People who like a unique set of beer","token_zscore":-1.3135867916,"plan_overlap":2},{"task":"youngest_over_35","language":"python-pandas","plan":{"filter":[{"line":1,"start":2,"end":35,"ntokens":14}],"null":[{"line":2,"start":2,"end":24,"ntokens":12},{"line":3,"start":4,"end":15,"ntokens":3},{"line":4,"start":2,"end":7,"ntokens":2}],"min":[{"line":5,"start":4,"end":48,"ntokens":15}],"name":[{"line":6,"start":4,"end":27,"ntokens":6}]},"source":"def youngest_over_35(people):\n  over_35 = people[people.age > 35]\n  if len(over_35) == 0: \n    return None\n  else:\n    youngest = over_35.loc[over_35.age.idxmin()]\n    return youngest['name']","author":"will","implementation":"","ntokens":65,"category":"Aggregation","language_name":"Python - Pandas","task_name":"Youngest person over 35","token_zscore":0.1354268101,"plan_overlap":0},{"task":"youngest_over_35","language":"sql","plan":{"name":[{"line":0,"start":0,"end":11,"ntokens":3}],"min":[{"line":3,"start":2,"end":17,"ntokens":6},{"line":4,"start":2,"end":13,"ntokens":3},{"line":1,"start":0,"end":11,"ntokens":3},{"line":2,"start":0,"end":13,"ntokens":7}],"filter":[{"line":5,"start":2,"end":16,"ntokens":8},{"line":4,"start":2,"end":13,"ntokens":3}]},"source":"SELECT name\nFROM people\nWHERE age = (\n  SELECT MIN(age)\n  FROM people\n  WHERE age > 35)\nLIMIT 1","author":"will","implementation":"","ntokens":36,"category":"Aggregation","language_name":"SQL - SQLite","task_name":"Youngest person over 35","token_zscore":-0.9479876707,"plan_overlap":1},{"task":"youngest_over_35","language":"datalog","plan":{"min":[{"line":2,"start":45,"end":46,"ntokens":1},{"line":2,"start":2,"end":34,"ntokens":9},{"line":1,"start":2,"end":13,"ntokens":5},{"line":1,"start":18,"end":20,"ntokens":1}],"filter":[{"line":2,"start":36,"end":44,"ntokens":1}],"name":[{"line":1,"start":14,"end":18,"ntokens":1},{"line":0,"start":17,"end":21,"ntokens":1}]},"source":"youngest_over_35(Name) :- \n  people(Age, Name), \n  Age = min Age : { people(Age, _), Age > 35 }.","author":"will","implementation":"","ntokens":25,"category":"Aggregation","language_name":"Datalog - Souffle","task_name":"Youngest person over 35","token_zscore":-1.3589379909,"plan_overlap":2},{"task":"youngest_over_35","language":"q","plan":{"filter":[{"line":0,"start":0,"end":45,"ntokens":18}],"name":[{"line":2,"start":9,"end":20,"ntokens":4},{"line":2,"start":20,"end":36,"ntokens":6},{"line":2,"start":59,"end":64,"ntokens":1}],"min":[{"line":2,"start":37,"end":57,"ntokens":10}]},"source":"old_enough: select from people where age > 35\nyoungest_over_35: \n  (first select name from old_enough where age = min(age)) `name","author":"will","implementation":"","ntokens":50,"category":"Aggregation","language_name":"Q - kdb+","task_name":"Youngest person over 35","token_zscore":-0.4249599903,"plan_overlap":1},{"task":"youngest_over_35","language":"python-functional","plan":{"filter":[{"line":1,"start":2,"end":48,"ntokens":26}],"min":[{"line":2,"start":2,"end":63,"ntokens":25}],"name":[{"line":3,"start":9,"end":25,"ntokens":5}]},"source":"def youngest_over_35(people):\n  over_35 = [p for p in people if p['age'] > 35]\n  youngest = min(over_35, default=None, key=lambda p: p['age'])\n  return youngest['name'] if youngest is not None else None","author":"will","implementation":"","ntokens":81,"category":"Aggregation","language_name":"Python - Functional","task_name":"Youngest person over 35","token_zscore":0.7331727305,"plan_overlap":0},{"task":"youngest_over_35","language":"python-imperative","plan":{"filter":[{"line":1,"start":2,"end":14,"ntokens":6},{"line":2,"start":2,"end":23,"ntokens":8},{"line":3,"start":4,"end":26,"ntokens":11},{"line":4,"start":6,"end":28,"ntokens":6}],"min":[{"line":6,"start":2,"end":17,"ntokens":5},{"line":7,"start":2,"end":24,"ntokens":8},{"line":8,"start":4,"end":59,"ntokens":22},{"line":9,"start":6,"end":23,"ntokens":5}],"name":[{"line":10,"start":9,"end":25,"ntokens":5}]},"source":"def youngest_over_35(people):\n  over_35 = []\n  for person in people:\n    if person['age'] > 35:\n      over_35.append(person)\n    \n  youngest = None\n  for person in over_35:\n    if youngest is None or person['age'] < youngest['age']:\n      youngest = person\n  return youngest['name'] if youngest is not None else None","author":"will","implementation":"separate","ntokens":108,"category":"Aggregation","language_name":"Python - Imperative","task_name":"Youngest person over 35","token_zscore":1.7418689712,"plan_overlap":0},{"task":"youngest_over_35","language":"python-imperative","plan":{"min":[{"line":1,"start":2,"end":17,"ntokens":5},{"line":2,"start":2,"end":23,"ntokens":8},{"line":4,"start":7,"end":60,"ntokens":20},{"line":3,"start":4,"end":6,"ntokens":2},{"line":5,"start":6,"end":23,"ntokens":5}],"filter":[{"line":2,"start":2,"end":23,"ntokens":8},{"line":3,"start":8,"end":26,"ntokens":9},{"line":3,"start":4,"end":6,"ntokens":2}],"name":[{"line":6,"start":2,"end":25,"ntokens":7}],"null":[{"line":6,"start":26,"end":59,"ntokens":13}]},"source":"def youngest_over_35(people):\n  youngest = None\n  for person in people:\n    if (person['age'] > 35 and \n       (youngest is None or person['age'] < youngest['age'])):\n      youngest = person\n  return youngest['name'] if youngest is not None else None","author":"will","implementation":"fused","ntokens":86,"category":"Aggregation","language_name":"Python - Imperative","task_name":"Youngest person over 35","token_zscore":0.9199683306,"plan_overlap":1},{"task":"youngest_over_35","language":"r","plan":{"name":[{"line":4,"start":4,"end":14,"ntokens":4}],"min":[{"line":3,"start":4,"end":29,"ntokens":8}],"filter":[{"line":2,"start":4,"end":24,"ntokens":10}]},"source":"youngest_over_35 <- function(people) {\n  people %>%\n    filter(age > 35) %>%\n    slice(which.min(age)) %>%\n    pull(name)\n}","author":"will","implementation":"","ntokens":40,"category":"Aggregation","language_name":"R - Tidyverse","task_name":"Youngest person over 35","token_zscore":-0.7985511905,"plan_overlap":0}]