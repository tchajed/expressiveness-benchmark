{"task": "reachable", "language": "python-imperative", "plan": {"graph": [{"line": 1, "start": 2, "end": 36}, {"line": 2, "start": 2, "end": 20}, {"line": 3, "start": 4, "end": 57}], "edge_match": [{"line": 13, "start": 4, "end": 44}, {"line": 14, "start": 6, "end": 28}], "edge_sequence": [{"line": 13, "start": 20, "end": 34}], "vertices": [{"line": 7, "start": 2, "end": 26}, {"line": 6, "start": 2, "end": 17}, {"line": 9, "start": 2, "end": 26}, {"line": 15, "start": 4, "end": 24}, {"line": 10, "start": 4, "end": 28}, {"line": 11, "start": 4, "end": 26}, {"line": 12, "start": 6, "end": 14}], "source": [{"line": 7, "start": 18, "end": 24}, {"line": 4, "start": 2, "end": 29}]}, "source": "def reachable(graph, query):\n  adjacency_list = defaultdict(list)\n  for edge in graph:\n    adjacency_list[edge[\"source\"]].append(edge[\"target\"])\n  source = query[0][\"source\"]\n\n  visited = set()\n  to_visit = set([source])\n    \n  while len(to_visit) > 0:\n    current = to_visit.pop()\n    if current in visited:\n      continue\n    for neighbor in adjacency_list[current]:\n      to_visit.add(neighbor)\n    visited.add(current)\n            \n  return list(visited)", "author": "scott", "implementation": ""}