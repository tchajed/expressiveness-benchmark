[{"task": "tom_hanks", "language": "python-imperative", "plan": {"director": [{"line": 7, "start": 10, "end": 40}, {"line": 8, "start": 4, "end": 22}, {"line": 2, "start": 2, "end": 21}, {"line": 5, "start": 6, "end": 25}], "actor": [{"line": 4, "start": 4, "end": 33}, {"line": 3, "start": 2, "end": 18}], "movies": [{"line": 6, "start": 8, "end": 36}]}, "source": "\ndef tom_hanks(actors,directors):\n  r_directors = set()\n  for a in actors:\n    if 'Tom Hanks' == a['actor']:\n      for d in directors:\n        if a['movie'] == d['movie']:\n          r_directors.add(d['director'])\n    return r_directors\n", "author": "g", "implementation": ""}, {"task": "tom_hanks", "language": "python-pandas", "plan": {"director": [{"line": 4, "start": 2, "end": 38}, {"line": 5, "start": 4, "end": 29}], "actor": [{"line": 3, "start": 3, "end": 34}], "movies": [{"line": 3, "start": 36, "end": 43}, {"line": 4, "start": 19, "end": 37}]}, "source": "\ndef tom_hanks(actors,directors):\n  movies = list(actors.loc[\n    actors['actor'] == 'Tom Hanks', 'movie'])\n  return directors[directors['movie'].\n    isin(movies)]['director']\n", "author": "g", "implementation": ""}, {"task": "tom_hanks", "language": "r", "plan": {"actor": [{"line": 2, "start": 4, "end": 36}], "movies": [{"line": 1, "start": 2, "end": 12}], "director": [{"line": 3, "start": 4, "end": 43}, {"line": 4, "start": 4, "end": 18}]}, "source": "tom_hanks <- function(actors, directors) {\n  actors %>%\n    filter(actor == \"Tom Hanks\") %>%\n    inner_join(directors, by = \"movie\") %>%\n    pull(director)\n}", "author": "g", "implementation": ""}, {"task": "tom_hanks", "language": "q", "plan": {"actor": [{"line": 2, "start": 3, "end": 30}], "director": [{"line": 2, "start": 32, "end": 41}, {"line": 1, "start": 3, "end": 18}, {"line": 1, "start": 31, "end": 57}], "movies": [{"line": 1, "start": 19, "end": 30}, {"line": 1, "start": 35, "end": 41}]}, "source": "tom_hanks:\n  (select director from actors ij (`movie xkey directors) \n   where actor ~\\: \"Tom Hanks\") `director", "author": "g", "implementation": ""}, {"task": "tom_hanks", "language": "sql", "plan": {"director": [{"line": 1, "start": 0, "end": 25}, {"line": 2, "start": 0, "end": 5}, {"line": 3, "start": 2, "end": 12}], "actor": [{"line": 7, "start": 0, "end": 30}, {"line": 4, "start": 2, "end": 19}], "movies": [{"line": 5, "start": 2, "end": 23}, {"line": 6, "start": 2, "end": 14}]}, "source": "\nSELECT directors.director\nFROM \n  directors \n  INNER JOIN actors\n  ON directors.movie = \n  actors.movie\nWHERE actors.actor=\"Tom Hanks\"\n", "author": "g", "implementation": ""}, {"task": "tom_hanks", "language": "datalog", "plan": {"director": [{"line": 3, "start": 2, "end": 28}, {"line": 1, "start": 10, "end": 18}], "actor": [{"line": 2, "start": 2, "end": 28}], "movies": [{"line": 2, "start": 21, "end": 26}, {"line": 3, "start": 21, "end": 26}]}, "source": "\ntom_hanks(Director):-\n  actors(\"Tom Hanks\",movie),\n  directors(Director,movie).\n", "author": "g", "implementation": ""}, {"task": "tom_hanks", "language": "python-functional", "plan": {"director": [{"line": 3, "start": 15, "end": 47}, {"line": 4, "start": 2, "end": 18}, {"line": 3, "start": 2, "end": 19}], "actor": [{"line": 2, "start": 46, "end": 71}, {"line": 2, "start": 23, "end": 71}], "movies": [{"line": 2, "start": 12, "end": 22}, {"line": 3, "start": 52, "end": 75}, {"line": 2, "start": 2, "end": 19}]}, "source": "\ndef tom_hanks(actors,directors):\n  movies = [a['movie'] for a in actors if a['actor'] == 'Tom Hanks']\n  directors = [d['director'] for d in directors if d['movie'] in movies]\n  return directors\n", "author": "g", "implementation": ""}, {"task": "inner_join", "language": "python-imperative", "plan": {"California": [{"line": 3, "start": 54, "end": 93}]}, "source": "  \ndef inner_join(customers,orders):\n    oids = []\n    cids = [customer['cid'] for customer in customers if customer['location'] == \"California\"]\n    oids = [order['oid'] for order in orders if order['cid'] in cids]\n    return oids\n", "author": "g", "implementation": ""}, {"task": "inner_join", "language": "python-pandas", "plan": {}, "source": "  \ndef inner_join(customers,orders):\n    joined = orders.join(customers, on=\"cid\",how=\"inner\",lsuffix=\"_j\")\n    joined = joined.loc[joined['location'] == \"California\"]\n    return pd.DataFrame({0: list(joined.oid)})\n\n", "author": "g", "implementation": ""}, {"task": "inner_join", "language": "sql", "plan": {}, "source": "  \n    SELECT orders.oid \n    FROM \n    (orders INNER JOIN customers ON orders.cid = customers.cid) \n    WHERE location=\"California\"\n", "author": "g", "implementation": ""}, {"task": "inner_join", "language": "datalog", "plan": {}, "source": "  \n    inner_join(oid):-\n    customers(cid,customer,location),\n    location=\"California\",\n    orders(cid,_,oid,_).\n", "author": "g", "implementation": ""}, {"task": "inner_join", "language": "python-functional", "plan": {}, "source": "  \ndef inner_join(customers,orders):\n    oids = []\n    for order in orders:\n        for customer in customers:\n            if customer['cid'] == order['cid']:\n                if customer['location'] == \"California\":\n                    oids.append(order['oid'])\n    return oids\n", "author": "g", "implementation": ""}, {"task": "continent_median_population", "language": "python-pandas", "plan": {"name": [{"line": 4, "start": 6, "end": 20}, {"line": 4, "start": 21, "end": 21}], "agg": [{"line": 3, "start": 6, "end": 26}], "iter": [{"line": 2, "start": 6, "end": 27}], "group": [{"line": 1, "start": 10, "end": 19}]}, "source": "def continent_median_population(countries):\n  return (countries\n      .groupby('continent')\n      .population.median()\n      .reset_index())", "author": "will", "implementation": ""}, {"task": "continent_median_population", "language": "sql", "plan": {"name": [{"line": 0, "start": 7, "end": 16}], "agg": [{"line": 0, "start": 18, "end": 47}, {"line": 2, "start": 2, "end": 13}, {"line": 3, "start": 4, "end": 21}, {"line": 4, "start": 30, "end": 59}, {"line": 5, "start": 4, "end": 16}, {"line": 6, "start": 31, "end": 39}, {"line": 7, "start": 2, "end": 17}, {"line": 8, "start": 0, "end": 6}, {"line": 9, "start": 2, "end": 48}, {"line": 10, "start": 2, "end": 55}], "group": [{"line": 4, "start": 7, "end": 29}, {"line": 6, "start": 7, "end": 29}], "iter": [{"line": 11, "start": 0, "end": 18}]}, "source": "SELECT continent, AVG(population) as population\nFROM\n  (SELECT *, \n    row_number() OVER \n      (PARTITION BY continent ORDER BY population) AS rank, \n    count() OVER \n      (PARTITION BY continent) as count\n  FROM countries)\nWHERE \n  (count % 2 = 1 AND rank = (count + 1) / 2) OR \n  (count % 2 = 0 AND ABS(rank - 0.5 - count / 2) = 0.5)\nGROUP BY continent", "author": "will", "implementation": ""}, {"task": "continent_median_population", "language": "datalog", "plan": {"iter": [{"line": 20, "start": 2, "end": 29}], "name": [{"line": 20, "start": 12, "end": 21}, {"line": 19, "start": 28, "end": 37}], "agg": [{"line": 19, "start": 39, "end": 45}, {"line": 21, "start": 2, "end": 53}, {"line": 22, "start": 2, "end": 27}, {"line": 23, "start": 4, "end": 54}, {"line": 24, "start": 3, "end": 26}, {"line": 25, "start": 4, "end": 47}, {"line": 26, "start": 4, "end": 43}, {"line": 27, "start": 4, "end": 28}, {"line": 0, "start": 0, "end": 46}, {"line": 1, "start": 0, "end": 50}, {"line": 2, "start": 0, "end": 0}, {"line": 3, "start": 0, "end": 56}, {"line": 4, "start": 0, "end": 45}, {"line": 5, "start": 2, "end": 44}, {"line": 6, "start": 2, "end": 25}, {"line": 7, "start": 2, "end": 21}, {"line": 8, "start": 4, "end": 32}, {"line": 9, "start": 4, "end": 22}, {"line": 10, "start": 4, "end": 18}, {"line": 11, "start": 2, "end": 4}, {"line": 12, "start": 2, "end": 18}, {"line": 13, "start": 4, "end": 32}, {"line": 14, "start": 4, "end": 22}, {"line": 15, "start": 4, "end": 20}, {"line": 16, "start": 4, "end": 12}, {"line": 17, "start": 2, "end": 4}], "group": [{"line": 21, "start": 26, "end": 52}, {"line": 8, "start": 14, "end": 23}, {"line": 5, "start": 12, "end": 21}]}, "source": ".decl unique_id(Country:symbol, Id:number)    \nunique_id(Country, $) :- countries(_, Country, _).\n\n.decl rank(Continent:symbol, R:number, Population:float)\nrank(Continent, R_less + R_eq, Population) :-\n  countries(Continent, Country, Population),\n  unique_id(Country, Id),\n  R_less = count : { \n    countries(Continent, C, P), \n    unique_id(C, Id2),\n    P < Population\n  },\n  R_eq = count : {\n    countries(Continent, C, P), \n    unique_id(C, Id2),\n    P = Population, \n    Id2 < Id\n  }.\n\ncontinent_median_population(Continent, Median) :-\n  countries(Continent, _, _),\n  Num_countries = count : countries(Continent, _, _),\n  ((Num_countries % 2 = 1, \n    rank(Continent, (Num_countries - 1) / 2, Median));\n   (Num_countries % 2 = 0,\n    rank(Continent, Num_countries / 2 - 1, P1),\n    rank(Continent, Num_countries / 2, P2),\n    Median = (P1 + P2) / 2)).     ", "author": "will", "implementation": ""}, {"task": "continent_median_population", "language": "q", "plan": {"agg": [{"line": 1, "start": 17, "end": 32}], "iter": [{"line": 1, "start": 33, "end": 45}], "group": [{"line": 1, "start": 46, "end": 60}], "name": [{"line": 1, "start": 33, "end": 45}]}, "source": "continent_median_population:\n  () xkey select med[population] by continent from countries", "author": "will", "implementation": ""}, {"task": "continent_median_population", "language": "python-functional", "plan": {"iter": [{"line": 1, "start": 2, "end": 55}, {"line": 7, "start": 4, "end": 31}, {"line": 3, "start": 4, "end": 13}, {"line": 20, "start": 4, "end": 46}, {"line": 18, "start": 2, "end": 10}, {"line": 21, "start": 2, "end": 3}], "group": [{"line": 4, "start": 22, "end": 41}, {"line": 5, "start": 6, "end": 36}, {"line": 6, "start": 4, "end": 5}, {"line": 3, "start": 15, "end": 16}], "agg": [{"line": 4, "start": 6, "end": 21}, {"line": 2, "start": 2, "end": 17}, {"line": 8, "start": 2, "end": 3}, {"line": 10, "start": 2, "end": 27}, {"line": 11, "start": 4, "end": 23}, {"line": 12, "start": 4, "end": 17}, {"line": 13, "start": 4, "end": 18}, {"line": 14, "start": 6, "end": 31}, {"line": 15, "start": 4, "end": 9}, {"line": 16, "start": 6, "end": 50}, {"line": 19, "start": 29, "end": 63}], "name": [{"line": 19, "start": 5, "end": 27}]}, "source": "def continent_median_population(countries):\n  continents = set([c['continent'] for c in countries])\n  populations = {\n    continent: [\n      c['population'] for c in countries \n      if c['continent'] == continent\n    ]\n    for continent in continents\n  }\n  \n  def compute_median(pops):\n    pops = sorted(pops)\n    N = len(pops)\n    if N % 2 == 1:\n      return pops[(N - 1) // 2]\n    else:\n      return (pops[N // 2 - 1] + pops[N // 2]) / 2  \n   \n  return [\n    {\"continent\": continent, \"population\": compute_median(pops)}\n    for continent, pops in populations.items()\n  ]", "author": "will", "implementation": ""}, {"task": "continent_median_population", "language": "python-imperative", "plan": {"iter": [{"line": 3, "start": 16, "end": 36}, {"line": 6, "start": 6, "end": 15}, {"line": 6, "start": 22, "end": 45}, {"line": 13, "start": 4, "end": 19}, {"line": 16, "start": 4, "end": 6}, {"line": 5, "start": 2, "end": 13}, {"line": 6, "start": 2, "end": 6}, {"line": 18, "start": 2, "end": 15}], "group": [{"line": 2, "start": 2, "end": 27}, {"line": 3, "start": 45, "end": 52}], "agg": [{"line": 1, "start": 2, "end": 33}, {"line": 3, "start": 4, "end": 16}, {"line": 3, "start": 36, "end": 45}, {"line": 3, "start": 52, "end": 67}, {"line": 6, "start": 17, "end": 45}, {"line": 7, "start": 4, "end": 15}, {"line": 8, "start": 4, "end": 17}, {"line": 9, "start": 4, "end": 18}, {"line": 10, "start": 6, "end": 33}, {"line": 11, "start": 4, "end": 9}, {"line": 12, "start": 6, "end": 52}, {"line": 15, "start": 6, "end": 26}, {"line": 6, "start": 2, "end": 6}], "name": [{"line": 14, "start": 6, "end": 29}]}, "source": "def continent_median_population(countries):\n  populations = defaultdict(list)\n  for country in countries:\n    populations[country['continent']].append(country['population'])\n  \n  output = []  \n  for continent, pops in populations.items():\n    pops.sort()\n    N = len(pops)\n    if N % 2 == 1:\n      median = pops[(N - 1) // 2]\n    else:\n      median = (pops[N // 2 - 1] + pops[N // 2]) / 2\n    output.append({\n      \"continent\": continent,\n      \"population\": median\n    })\n    \n  return output", "author": "will", "implementation": ""}, {"task": "continent_median_population", "language": "r", "plan": {"iter": [{"line": 1, "start": 2, "end": 15}], "group": [{"line": 2, "start": 4, "end": 27}], "agg": [{"line": 3, "start": 4, "end": 46}], "name": [{"line": 1, "start": 2, "end": 15}]}, "source": "continent_median_population <- function(countries) {\n  countries %>%\n    group_by(continent) %>%\n    summarize(population = median(population))\n}", "author": "will", "implementation": ""}, {"task": "youngest_over_35", "language": "python-pandas", "plan": {"filter": [{"line": 1, "start": 2, "end": 35}], "null": [{"line": 2, "start": 2, "end": 24}, {"line": 3, "start": 4, "end": 15}, {"line": 4, "start": 2, "end": 7}], "min": [{"line": 5, "start": 4, "end": 48}], "name": [{"line": 6, "start": 4, "end": 27}]}, "source": "def youngest_over_35(people):\n  over_35 = people[people.age > 35]\n  if len(over_35) == 0: \n    return None\n  else:\n    youngest = over_35.loc[over_35.age.idxmin()]\n    return youngest['name']", "author": "will", "implementation": ""}, {"task": "youngest_over_35", "language": "sql", "plan": {"name": [{"line": 0, "start": 0, "end": 11}], "min": [{"line": 3, "start": 2, "end": 17}, {"line": 4, "start": 2, "end": 13}, {"line": 1, "start": 0, "end": 11}, {"line": 2, "start": 0, "end": 13}], "filter": [{"line": 5, "start": 2, "end": 16}, {"line": 4, "start": 2, "end": 13}]}, "source": "SELECT name\nFROM people\nWHERE age = (\n  SELECT MIN(age)\n  FROM people\n  WHERE age > 35)\nLIMIT 1", "author": "will", "implementation": ""}, {"task": "youngest_over_35", "language": "datalog", "plan": {"min": [{"line": 2, "start": 45, "end": 46}, {"line": 2, "start": 2, "end": 34}, {"line": 1, "start": 2, "end": 13}, {"line": 1, "start": 18, "end": 20}], "filter": [{"line": 2, "start": 36, "end": 44}], "name": [{"line": 1, "start": 14, "end": 18}, {"line": 0, "start": 17, "end": 21}]}, "source": "youngest_over_35(Name) :- \n  people(Age, Name), \n  Age = min Age : { people(Age, _), Age > 35 }.", "author": "will", "implementation": ""}, {"task": "youngest_over_35", "language": "q", "plan": {"filter": [{"line": 0, "start": 0, "end": 45}], "name": [{"line": 2, "start": 9, "end": 20}, {"line": 2, "start": 20, "end": 36}, {"line": 2, "start": 59, "end": 64}], "min": [{"line": 2, "start": 37, "end": 57}]}, "source": "old_enough: select from people where age > 35\nyoungest_over_35: \n  (first select name from old_enough where age = min(age)) `name", "author": "will", "implementation": ""}, {"task": "youngest_over_35", "language": "python-functional", "plan": {"filter": [{"line": 1, "start": 2, "end": 48}], "min": [{"line": 2, "start": 2, "end": 63}], "name": [{"line": 3, "start": 9, "end": 25}]}, "source": "def youngest_over_35(people):\n  over_35 = [p for p in people if p['age'] > 35]\n  youngest = min(over_35, default=None, key=lambda p: p['age'])\n  return youngest['name'] if youngest is not None else None", "author": "will", "implementation": ""}, {"task": "youngest_over_35", "language": "python-imperative", "plan": {"filter": [{"line": 1, "start": 2, "end": 14}, {"line": 2, "start": 2, "end": 23}, {"line": 3, "start": 4, "end": 26}, {"line": 4, "start": 6, "end": 28}], "min": [{"line": 6, "start": 2, "end": 17}, {"line": 7, "start": 2, "end": 24}, {"line": 8, "start": 4, "end": 59}, {"line": 9, "start": 6, "end": 23}], "name": [{"line": 10, "start": 9, "end": 25}]}, "source": "def youngest_over_35(people):\n  over_35 = []\n  for person in people:\n    if person['age'] > 35:\n      over_35.append(person)\n    \n  youngest = None\n  for person in over_35:\n    if youngest is None or person['age'] < youngest['age']:\n      youngest = person\n  return youngest['name'] if youngest is not None else None", "author": "will", "implementation": "separate"}, {"task": "youngest_over_35", "language": "python-imperative", "plan": {"min": [{"line": 1, "start": 2, "end": 17}, {"line": 2, "start": 2, "end": 23}, {"line": 4, "start": 7, "end": 60}, {"line": 3, "start": 4, "end": 6}, {"line": 5, "start": 6, "end": 23}], "filter": [{"line": 2, "start": 2, "end": 23}, {"line": 3, "start": 8, "end": 26}, {"line": 3, "start": 4, "end": 6}], "name": [{"line": 6, "start": 2, "end": 25}], "null": [{"line": 6, "start": 26, "end": 59}]}, "source": "def youngest_over_35(people):\n  youngest = None\n  for person in people:\n    if (person['age'] > 35 and \n       (youngest is None or person['age'] < youngest['age'])):\n      youngest = person\n  return youngest['name'] if youngest is not None else None", "author": "will", "implementation": "fused"}, {"task": "youngest_over_35", "language": "r", "plan": {"name": [{"line": 4, "start": 4, "end": 14}], "min": [{"line": 3, "start": 4, "end": 29}], "filter": [{"line": 2, "start": 4, "end": 24}]}, "source": "youngest_over_35 <- function(people) {\n  people %>%\n    filter(age > 35) %>%\n    slice(which.min(age)) %>%\n    pull(name)\n}", "author": "will", "implementation": ""}, {"task": "reachable", "language": "sql", "plan": {"step": [{"line": 2, "start": 0, "end": 43}, {"line": 4, "start": 0, "end": 33}, {"line": 5, "start": 2, "end": 41}, {"line": 6, "start": 2, "end": 30}], "source": [{"line": 9, "start": 14, "end": 37}, {"line": 11, "start": 0, "end": 37}], "edge_sequence": [{"line": 4, "start": 2, "end": 34}, {"line": 7, "start": 2, "end": 41}], "edge_match": [{"line": 8, "start": 2, "end": 30}], "vertices": [{"line": 6, "start": 2, "end": 33}, {"line": 1, "start": 0, "end": 23}, {"line": 2, "start": 2, "end": 34}, {"line": 3, "start": 2, "end": 7}, {"line": 5, "start": 2, "end": 7}, {"line": 6, "start": 2, "end": 8}, {"line": 5, "start": 2, "end": 7}, {"line": 6, "start": 2, "end": 33}, {"line": 5, "start": 2, "end": 7}, {"line": 10, "start": 0, "end": 33}]}, "source": "WITH RECURSIVE\nclosure(source, target) AS (\n  SELECT source, source FROM graph\n  UNION\n  SELECT source, target FROM graph\n  UNION\n  SELECT edge.source, path.target\n  FROM closure as path JOIN graph as edge\n  ON edge.target = path.source\n)\nSELECT S.target FROM closure as S\nJOIN query ON S.source = query.source", "author": "scott", "implementation": ""}, {"task": "reachable", "language": "python-imperative", "plan": {"graph": [{"line": 1, "start": 2, "end": 36}, {"line": 2, "start": 2, "end": 20}, {"line": 3, "start": 4, "end": 57}], "edge_match": [{"line": 13, "start": 4, "end": 44}, {"line": 14, "start": 6, "end": 28}], "edge_sequence": [{"line": 13, "start": 20, "end": 34}], "vertices": [{"line": 7, "start": 2, "end": 26}, {"line": 6, "start": 2, "end": 17}, {"line": 9, "start": 2, "end": 26}, {"line": 15, "start": 4, "end": 24}, {"line": 10, "start": 4, "end": 28}, {"line": 11, "start": 4, "end": 26}, {"line": 12, "start": 6, "end": 14}], "source": [{"line": 7, "start": 18, "end": 24}, {"line": 4, "start": 2, "end": 29}]}, "source": "def reachable(graph, query):\n  adjacency_list = defaultdict(list)\n  for edge in graph:\n    adjacency_list[edge[\"source\"]].append(edge[\"target\"])\n  source = query[0][\"source\"]\n\n  visited = set()\n  to_visit = set([source])\n    \n  while len(to_visit) > 0:\n    current = to_visit.pop()\n    if current in visited:\n      continue\n    for neighbor in adjacency_list[current]:\n      to_visit.add(neighbor)\n    visited.add(current)\n            \n  return list(visited)", "author": "scott", "implementation": ""}, {"task": "reachable", "language": "python-functional", "plan": {"edge_match": [{"line": 6, "start": 6, "end": 33}], "edge_sequence": [{"line": 5, "start": 6, "end": 23}], "vertices": [{"line": 10, "start": 2, "end": 16}, {"line": 11, "start": 4, "end": 15}, {"line": 12, "start": 4, "end": 43}, {"line": 15, "start": 14, "end": 22}, {"line": 8, "start": 4, "end": 34}, {"line": 3, "start": 6, "end": 20}, {"line": 4, "start": 6, "end": 27}, {"line": 2, "start": 4, "end": 20}], "source": [{"line": 14, "start": 2, "end": 29}, {"line": 15, "start": 24, "end": 37}]}, "source": "def reachable(graph, query):\n  def step(visited):\n    frontier = set([\n      edge[\"target\"]\n      for vertex in visited\n      for edge in graph\n      if vertex == edge[\"source\"]\n    ])\n    return frontier.union(visited)\n\n  def fix(f, x):\n    next = f(x)\n    return x if next == x else fix(f, next)\n\n  source = query[0][\"source\"]\n  return list(fix(step, set([source])))", "author": "scott", "implementation": ""}, {"task": "reachable", "language": "datalog", "plan": {"graph": [], "source": [{"line": 3, "start": 0, "end": 35}, {"line": 4, "start": 0, "end": 47}], "vertices": [{"line": 4, "start": 44, "end": 45}, {"line": 0, "start": 11, "end": 31}, {"line": 4, "start": 44, "end": 45}, {"line": 1, "start": 0, "end": 26}, {"line": 2, "start": 0, "end": 38}, {"line": 4, "start": 44, "end": 45}, {"line": 4, "start": 10, "end": 11}], "edge_match": [{"line": 2, "start": 23, "end": 24}, {"line": 2, "start": 32, "end": 33}], "edge_sequence": [{"line": 1, "start": 14, "end": 25}, {"line": 2, "start": 14, "end": 37}]}, "source": ".decl path(x: symbol, y: symbol)\npath(x, y) :- graph(x, y).\npath(x, y) :- graph(x, z), path(z, y).\nreachable(source) :- query(source).\nreachable(x) :- query(source), path(source, x).", "author": "scott", "implementation": ""}, {"task": "reachable", "language": "q", "plan": {"graph": [{"line": 0, "start": 0, "end": 27}, {"line": 1, "start": 0, "end": 51}, {"line": 2, "start": 0, "end": 31}, {"line": 3, "start": 0, "end": 12}, {"line": 4, "start": 2, "end": 66}], "source": [{"line": 6, "start": 0, "end": 48}, {"line": 7, "start": 0, "end": 49}], "edge_sequence": [{"line": 5, "start": 0, "end": 62}], "vertices": [{"line": 5, "start": 0, "end": 62}], "edge_match": [{"line": 5, "start": 0, "end": 62}]}, "source": "graph: (first') each graph;\nnodes: asc distinct graph[`source], graph[`target];\nadj_list: `source xgroup graph;\nadj_matrix: \n  {in[;x] each nodes} each nodes ,' (adj_list each nodes) `target;\niterated_matrix: last ({x | any each (x *\\: x)} \\) adj_matrix;\nquery_idx: nodes ? (first first query[`source]);\nreachable: nodes where iterated_matrix[query_idx]", "author": "scott", "implementation": ""}, {"task": "process_tweets", "language": "sql", "plan": {"lowercase": [{"line": 0, "start": 7, "end": 18}], "select": [{"line": 0, "start": 19, "end": 30}, {"line": 0, "start": 0, "end": 6}], "iter": [{"line": 1, "start": 0, "end": 9}], "filter": [{"line": 2, "start": 0, "end": 46}]}, "source": "SELECT LOWER(body) as body, ts\nFROM data\nWHERE language = \"en\" and is_retweet = \"false\"", "author": "scott", "implementation": ""}, {"task": "process_tweets", "language": "python-imperative", "plan": {"iter": [{"line": 2, "start": 2, "end": 20}, {"line": 1, "start": 2, "end": 13}, {"line": 9, "start": 2, "end": 15}], "filter": [{"line": 3, "start": 4, "end": 37}, {"line": 4, "start": 8, "end": 40}], "lowercase": [{"line": 6, "start": 16, "end": 38}], "select": [{"line": 5, "start": 6, "end": 21}, {"line": 6, "start": 8, "end": 15}, {"line": 7, "start": 8, "end": 25}, {"line": 8, "start": 6, "end": 8}]}, "source": "def process_tweets(data):\n  result = []\n  for value in data:\n    if (value[\"language\"] == \"en\" and\n        value[\"is_retweet\"] == \"false\"):\n      result.append({\n        \"body\": value[\"body\"].lower(),\n        \"ts\": value[\"ts\"]\n      })\n  return result", "author": "scott", "implementation": ""}, {"task": "process_tweets", "language": "python-functional", "plan": {"lowercase": [{"line": 2, "start": 13, "end": 34}], "filter": [{"line": 5, "start": 4, "end": 36}, {"line": 6, "start": 7, "end": 37}], "select": [{"line": 3, "start": 5, "end": 23}, {"line": 2, "start": 4, "end": 13}], "iter": [{"line": 4, "start": 4, "end": 21}, {"line": 7, "start": 2, "end": 3}, {"line": 1, "start": 2, "end": 10}]}, "source": "def process_tweets(data):\n  return [\n    {\"body\": value[\"body\"].lower(),\n     \"ts\": value[\"ts\"]}\n    for value in data\n    if value[\"language\"] == \"en\" and\n       value[\"is_retweet\"] == \"false\" \n  ]", "author": "scott", "implementation": ""}, {"task": "process_tweets", "language": "python-pandas", "plan": {"iter": [{"line": 1, "start": 11, "end": 15}], "filter": [{"line": 1, "start": 15, "end": 16}, {"line": 2, "start": 4, "end": 29}, {"line": 3, "start": 4, "end": 33}], "lowercase": [{"line": 4, "start": 2, "end": 54}], "select": [{"line": 5, "start": 2, "end": 31}]}, "source": "def process_tweets(data):\n  result = data[\n    (data.language == 'en') &\n    (data.is_retweet == 'false')]\n  result.body = result.body.apply(lambda s: s.lower())\n  return result[[\"body\", \"ts\"]]", "author": "scott", "implementation": ""}, {"task": "process_tweets", "language": "r", "plan": {"iter": [{"line": 1, "start": 2, "end": 10}], "filter": [{"line": 2, "start": 4, "end": 56}], "select": [{"line": 4, "start": 4, "end": 20}], "lowercase": [{"line": 3, "start": 4, "end": 36}]}, "source": "process_tweets <- function(data) {\n  data %>%\n    filter(language == \"en\" & is_retweet == \"false\") %>%\n    mutate(body = tolower(body)) %>%\n    select(ts, body)\n}", "author": "scott", "implementation": ""}, {"task": "process_tweets", "language": "q", "plan": {"lowercase": [{"line": 1, "start": 9, "end": 15}, {"line": 1, "start": 19, "end": 20}], "select": [{"line": 1, "start": 15, "end": 19}, {"line": 1, "start": 20, "end": 24}, {"line": 1, "start": 2, "end": 9}], "iter": [{"line": 1, "start": 25, "end": 34}], "filter": [{"line": 2, "start": 2, "end": 56}]}, "source": "process_tweets:\n  select lower[body], ts from data \n  where (is_retweet ~\\: \"false\") and (language ~\\: \"en\")", "author": "scott", "implementation": ""}, {"task": "changing_list", "language": "python-imperative", "plan": {}, "source": "\nimport copy\ndef get_mean(ls):\n  sum = 0\n  for e in ls:\n    sum += e['value']\n  return sum/len(ls)\n\ndef changing_list(list):\n  start_mean = get_mean(list)\n  for i,elem in enumerate(list):\n    new_ls = copy.deepcopy(list)\n    del new_ls[i]\n    mean = get_mean(new_ls)\n    if abs(mean - start_mean) < 0.1:\n      return i\n", "author": "g", "implementation": ""}, {"task": "changing_list", "language": "datalog", "plan": {}, "source": "\n    .decl avg(a:number)\n    avg(first_sum/first_count) :-\n      first_count = count : list(_, _),\n      real_count = first_count - 1,\n      first_sum = sum value:{list(_,value)}.\n      \n    changing_list(id):-\n    avg(a),\n    id = a.\n", "author": "g", "implementation": ""}, {"task": "changing_list", "language": "python-functional", "plan": {}, "source": "\ndef changing_list(list):\n  start_mean = sum([l['value'] for l in list])/len(list)\n  diff = lambda m, sm: abs(m - sm)\n    \n  for i,elem in enumerate(list):\n    new_ls = [x['value'] for x in list if x != elem]\n    mean = sum(new_ls)/len(new_ls)\n    if diff(mean,start_mean) < 0.1:\n      return i\n", "author": "g", "implementation": ""}, {"task": "average_window", "language": "sql", "plan": {"key": [{"line": 2, "start": 9, "end": 30}], "group by": [{"line": 2, "start": 0, "end": 8}, {"line": 1, "start": 0, "end": 9}], "average": [{"line": 0, "start": 7, "end": 18}], "output_order": [{"line": 3, "start": 0, "end": 13}, {"line": 3, "start": 0, "end": 13}, {"line": 3, "start": 0, "end": 13}]}, "source": "SELECT AVG(x) as x\nFROM data\nGROUP BY cast(time / 7 as int)\nORDER BY time", "author": "scott", "implementation": ""}, {"task": "average_window", "language": "python-imperative", "plan": {"key": [{"line": 1, "start": 2, "end": 20}, {"line": 2, "start": 4, "end": 40}], "output_order": [{"line": 5, "start": 2, "end": 36}], "group by": [{"line": 9, "start": 2, "end": 24}, {"line": 10, "start": 4, "end": 31}, {"line": 11, "start": 4, "end": 37}, {"line": 7, "start": 2, "end": 34}, {"line": 3, "start": 2, "end": 19}, {"line": 4, "start": 4, "end": 13}], "average": [{"line": 12, "start": 6, "end": 34}, {"line": 13, "start": 6, "end": 54}, {"line": 8, "start": 2, "end": 32}, {"line": 6, "start": 2, "end": 13}, {"line": 14, "start": 4, "end": 23}, {"line": 15, "start": 4, "end": 14}, {"line": 17, "start": 2, "end": 15}, {"line": 16, "start": 2, "end": 30}]}, "source": "def average_window(data):\n  def window(value):\n    return math.floor(value[\"time\"] / 7)\n  if len(data) < 1:\n    return []\n  data.sort(key=lambda v: v[\"time\"])\n  result = []\n  current_window = window(data[0])\n  total, count = data[0][\"x\"], 1\n  for value in data[1:]:\n    time_window = window(value)\n    if time_window != current_window:\n      result.append(total / count)\n      current_window, total, count = time_window, 0, 0\n    total += value[\"x\"]\n    count += 1\n  result.append(total / count)\n  return result", "author": "scott", "implementation": ""}, {"task": "average_window", "language": "python-functional", "plan": {"output_order": [{"line": 5, "start": 4, "end": 35}], "group by": [{"line": 3, "start": 2, "end": 20}, {"line": 4, "start": 4, "end": 56}, {"line": 5, "start": 4, "end": 35}, {"line": 6, "start": 2, "end": 3}, {"line": 9, "start": 4, "end": 32}, {"line": 7, "start": 2, "end": 10}, {"line": 10, "start": 2, "end": 3}], "key": [{"line": 1, "start": 2, "end": 20}, {"line": 2, "start": 4, "end": 40}], "average": [{"line": 8, "start": 4, "end": 29}]}, "source": "def average_window(data):\n  def window(value):\n    return math.floor(value[\"time\"] / 7)\n  grouped_values = [\n    [point[\"x\"] for point in data if window(point) == w]\n    for w in set(map(window, data))\n  ]\n  return [\n    sum(values) / len(values)\n    for values in grouped_values\n  ]", "author": "scott", "implementation": ""}, {"task": "average_window", "language": "python-pandas", "plan": {"key": [{"line": 1, "start": 2, "end": 16}, {"line": 2, "start": 4, "end": 28}], "output_order": [{"line": 3, "start": 12, "end": 36}], "group by": [{"line": 4, "start": 35, "end": 50}, {"line": 4, "start": 17, "end": 35}, {"line": 5, "start": 2, "end": 29}, {"line": 3, "start": 2, "end": 11}], "average": [{"line": 4, "start": 51, "end": 57}]}, "source": "def average_window(data):\n  def window(t):\n    return math.floor(t / 7)\n  result = (data.sort_values(\"time\")\n                .set_index(\"time\").groupby(window).mean())\n  return result['x'].tolist()", "author": "scott", "implementation": ""}, {"task": "average_window", "language": "datalog", "plan": {"average": [{"line": 5, "start": 18, "end": 27}, {"line": 6, "start": 2, "end": 37}, {"line": 7, "start": 6, "end": 44}], "group by": [{"line": 0, "start": 0, "end": 23}, {"line": 2, "start": 0, "end": 35}, {"line": 3, "start": 0, "end": 31}, {"line": 4, "start": 0, "end": 41}, {"line": 1, "start": 0, "end": 26}], "key": [{"line": 1, "start": 7, "end": 10}, {"line": 3, "start": 9, "end": 12}, {"line": 1, "start": 7, "end": 10}], "output_order": []}, "source": ".decl window(w: number)\nwindow(t/7) :- data(t, _).\n.decl windowed(w: number, x: float)\nwindowed(t/7, x) :- data(t, x).\n.decl windowed_total(w: number, x: float)\nwindowed_total(w, total / n) :- window(w),\n  total = sum x : { windowed(w, x) },\n      n = sum z : { windowed(w, x), z=1.0 }.\naverage_window(v) :- windowed_total(_, v).", "author": "scott", "implementation": ""}, {"task": "average_window", "language": "r", "plan": {"average": [{"line": 3, "start": 4, "end": 33}, {"line": 4, "start": 4, "end": 13}], "key": [{"line": 2, "start": 19, "end": 27}], "group by": [{"line": 1, "start": 2, "end": 11}, {"line": 2, "start": 4, "end": 19}, {"line": 2, "start": 28, "end": 33}]}, "source": "average_window <- function(data) {\n  data %>% \n    group_by(floor(time / 7)) %>% \n    summarize(avg = mean(x)) %>% \n    pull(avg)\n}", "author": "scott", "implementation": ""}, {"task": "average_window", "language": "q", "plan": {"output_order": [{"line": 1, "start": 15, "end": 22}], "average": [{"line": 1, "start": 23, "end": 28}], "key": [{"line": 1, "start": 32, "end": 33}], "group by": [{"line": 1, "start": 29, "end": 31}, {"line": 1, "start": 34, "end": 43}]}, "source": "average_window:\n  (value select[<time] avg x by 7 xbar time from data) `x", "author": "scott", "implementation": ""}, {"task": "documents_with_infrequent_words", "language": "python-pandas", "plan": {"word": [{"line": 1, "start": 2, "end": 52}], "frequency": [{"line": 2, "start": 2, "end": 37}, {"line": 3, "start": 2, "end": 49}], "documents": [{"line": 4, "start": 2, "end": 30}, {"line": 5, "start": 4, "end": 44}, {"line": 6, "start": 2, "end": 45}]}, "source": "def documents_with_infrequent_words(documents):\n  words = documents.text.str.split(\" \", expand=True)\n  freq = words.stack().value_counts()\n  infrequent_words = freq[freq == 1].index.values\n  infrequent_docs = documents[\n    np.isin(words.values, infrequent_words)]\n  return infrequent_docs.id.unique().tolist()", "author": "will", "implementation": ""}, {"task": "documents_with_infrequent_words", "language": "sql", "plan": {"word": [{"line": 3, "start": 0, "end": 42}, {"line": 4, "start": 2, "end": 52}, {"line": 5, "start": 0, "end": 51}, {"line": 6, "start": 0, "end": 51}], "documents": [{"line": 8, "start": 0, "end": 18}, {"line": 9, "start": 0, "end": 5}, {"line": 10, "start": 2, "end": 11}, {"line": 11, "start": 2, "end": 12}, {"line": 14, "start": 26, "end": 38}, {"line": 12, "start": 2, "end": 23}, {"line": 13, "start": 3, "end": 13}, {"line": 16, "start": 2, "end": 44}, {"line": 17, "start": 2, "end": 36}, {"line": 18, "start": 2, "end": 36}, {"line": 19, "start": 2, "end": 25}, {"line": 15, "start": 0, "end": 5}], "frequency": [{"line": 14, "start": 3, "end": 24}]}, "source": "-- NOTE: SQLite tokenize is case-insensitive by default, \n-- so this solution is NOT exactly like the others\n\nCREATE VIRTUAL TABLE doc_index USING fts4(\n  text, id, content=documents, tokenize=simple);    \nINSERT INTO doc_index(doc_index) VALUES('rebuild');\nCREATE VIRTUAL TABLE words USING fts4aux(doc_index);    \n\nSELECT DISTINCT id\nFROM \n  documents\n  CROSS JOIN\n  (SELECT DISTINCT term\n   FROM words\n   WHERE occurrences = 1) unique_words\nWHERE\n  (LOWER(text) LIKE '% ' || term || ' %') OR\n  (LOWER(text) LIKE term || ' %') OR\n  (LOWER(text) LIKE '% ' || term) OR\n  (LOWER(text) LIKE term)", "author": "will", "implementation": ""}, {"task": "documents_with_infrequent_words", "language": "datalog", "plan": {"word": [{"line": 0, "start": 0, "end": 50}, {"line": 1, "start": 0, "end": 23}, {"line": 2, "start": 2, "end": 39}, {"line": 3, "start": 0, "end": 27}, {"line": 4, "start": 2, "end": 49}, {"line": 5, "start": 0, "end": 29}, {"line": 6, "start": 2, "end": 57}, {"line": 8, "start": 0, "end": 63}, {"line": 9, "start": 0, "end": 32}, {"line": 10, "start": 2, "end": 25}, {"line": 11, "start": 2, "end": 26}, {"line": 12, "start": 2, "end": 35}, {"line": 13, "start": 2, "end": 42}, {"line": 14, "start": 2, "end": 53}, {"line": 15, "start": 2, "end": 32}, {"line": 16, "start": 2, "end": 23}], "frequency": [{"line": 21, "start": 2, "end": 35}], "documents": [{"line": 19, "start": 2, "end": 19}, {"line": 20, "start": 2, "end": 24}]}, "source": ".decl substrs(Text:symbol, Idx:number, Len:number)\nsubstrs(Text, 0, 1) :- \n  documents(_, Text), strlen(Text) > 0.\nsubstrs(Text, 0, Len+1) :- \n  substrs(Text, 0, Len), Len + 1 <= strlen(Text).\nsubstrs(Text, Idx+1, Len) :- \n  substrs(Text, Idx, Len), Idx + Len + 1 <= strlen(Text).\n\n.decl token(Docid:number, Text:symbol, Idx:number, Word:symbol)\ntoken(Docid, Text, Idx, Word) :-\n  documents(Docid, Text),\n  substrs(Text, Idx, Len),\n  Prev = Idx - 1, Next = Idx + Len,\n  (Prev < 0; \" \" = substr(Text, Prev, 1)),\n  (Next = strlen(Text); \" \" = substr(Text, Next, 1)),\n  Word = substr(Text, Idx, Len),\n  !contains(\" \", Word).\n\ndocuments_with_infrequent_words(Id) :-\n  documents(Id, _),\n  token(Id, _, _, Word),\n  1 = count : token(_, _, _, Word).", "author": "will", "implementation": ""}, {"task": "documents_with_infrequent_words", "language": "q", "plan": {"word": [{"line": 0, "start": 0, "end": 38}], "frequency": [{"line": 1, "start": 0, "end": 34}, {"line": 2, "start": 0, "end": 20}], "documents": [{"line": 4, "start": 2, "end": 70}]}, "source": "words: (\" \" vs) each documents[`text];\nfreq: count each group raze words;\nuniq: where[freq=1];\ndocuments_with_infrequent_words:\n  (select id from documents where '[any; in\\: [;uniq]] each words) `id", "author": "will", "implementation": ""}, {"task": "documents_with_infrequent_words", "language": "python-functional", "plan": {"word": [{"line": 1, "start": 2, "end": 55}], "frequency": [{"line": 2, "start": 2, "end": 46}, {"line": 3, "start": 2, "end": 10}, {"line": 4, "start": 4, "end": 33}, {"line": 5, "start": 4, "end": 31}, {"line": 6, "start": 2, "end": 3}, {"line": 7, "start": 2, "end": 26}, {"line": 8, "start": 4, "end": 41}, {"line": 9, "start": 4, "end": 17}, {"line": 10, "start": 2, "end": 4}], "documents": [{"line": 11, "start": 2, "end": 21}, {"line": 12, "start": 4, "end": 53}, {"line": 13, "start": 4, "end": 42}, {"line": 14, "start": 2, "end": 3}, {"line": 15, "start": 2, "end": 24}]}, "source": "def documents_with_infrequent_words(documents):\n  words = [doc[\"text\"].split(\" \") for doc in documents]\n  words_flat = [w for ws in words for w in ws]\n  freq = {\n    word: words_flat.count(word) \n    for word in set(words_flat)\n  }\n  infrequent_words = set([\n    word for word, count in freq.items() \n    if count == 1\n  ])\n  infrequent_docs = [\n    documents[i][\"id\"] for i, ws in enumerate(words) \n    if len(set(ws) & infrequent_words) > 0\n  ]\n  return infrequent_docs", "author": "will", "implementation": ""}, {"task": "documents_with_infrequent_words", "language": "python-imperative", "plan": {"word": [{"line": 4, "start": 23, "end": 45}], "frequency": [{"line": 1, "start": 1, "end": 12}, {"line": 2, "start": 2, "end": 25}, {"line": 3, "start": 2, "end": 23}, {"line": 4, "start": 4, "end": 22}, {"line": 5, "start": 4, "end": 33}, {"line": 6, "start": 6, "end": 21}, {"line": 8, "start": 2, "end": 26}, {"line": 9, "start": 2, "end": 34}, {"line": 10, "start": 4, "end": 18}, {"line": 11, "start": 6, "end": 32}], "documents": [{"line": 13, "start": 2, "end": 22}, {"line": 14, "start": 2, "end": 23}, {"line": 15, "start": 4, "end": 33}, {"line": 16, "start": 6, "end": 34}, {"line": 17, "start": 8, "end": 41}, {"line": 18, "start": 8, "end": 13}, {"line": 20, "start": 0, "end": 24}]}, "source": "def documents_with_infrequent_words(documents):\n  words = {}\n  freq = defaultdict(int)\n  for doc in documents:\n    words[doc[\"id\"]] = doc[\"text\"].split(\" \")\n    for word in words[doc[\"id\"]]:\n      freq[word] += 1\n      \n  infrequent_words = set()\n  for word, count in freq.items():\n    if count == 1:\n      infrequent_words.add(word)\n      \n  infrequent_docs = []\n  for doc in documents:\n    for word in words[doc[\"id\"]]:\n      if word in infrequent_words:\n        infrequent_docs.append(doc[\"id\"])\n        break\n        \n  return infrequent_docs", "author": "will", "implementation": ""}, {"task": "documents_with_infrequent_words", "language": "r", "plan": {"documents": [{"line": 6, "start": 2, "end": 12}, {"line": 7, "start": 4, "end": 43}, {"line": 8, "start": 4, "end": 16}, {"line": 9, "start": 4, "end": 12}], "frequency": [{"line": 4, "start": 2, "end": 31}, {"line": 5, "start": 2, "end": 41}], "word": [{"line": 1, "start": 2, "end": 24}, {"line": 2, "start": 4, "end": 43}, {"line": 3, "start": 4, "end": 12}]}, "source": "documents_with_infrequent_words <- function(documents) {\n  split <- documents %>%\n    mutate(word = str_split(text, \" \")) %>%\n    unnest()\n  freq <- split %>% count(word)\n  unique_words <- freq %>% filter(n == 1)\n  split %>% \n    filter(word %in% unique_words$word) %>%\n    pull(id) %>%\n    unique()\n}", "author": "will", "implementation": ""}, {"task": "row_per_child", "language": "python-pandas", "plan": {"each-family": [{"line": 2, "start": 4, "end": 12}], "child-ID": [{"line": 7, "start": 2, "end": 48}], "family-ID": [{"line": 5, "start": 4, "end": 14}], "each-child": [{"line": 6, "start": 4, "end": 13}, {"line": 4, "start": 4, "end": 17}, {"line": 1, "start": 7, "end": 23}], "dob-height": [{"line": 3, "start": 4, "end": 32}]}, "source": "def row_per_child(families):\n  df = pd.wide_to_long(\n    families, \n    stubnames=['dob', 'height'], \n    sep=\"_child\", \n    i='family', \n    j='child').reset_index()\n  df.child = df.child.map(lambda c: f'child{c}')\n  return df", "author": "will", "implementation": ""}, {"task": "row_per_child", "language": "sql", "plan": {"child-ID": [{"line": 2, "start": 2, "end": 30}], "dob-height": [{"line": 3, "start": 2, "end": 14}, {"line": 4, "start": 4, "end": 27}, {"line": 5, "start": 4, "end": 27}, {"line": 6, "start": 4, "end": 27}, {"line": 7, "start": 3, "end": 15}, {"line": 8, "start": 2, "end": 14}, {"line": 9, "start": 4, "end": 30}, {"line": 10, "start": 4, "end": 30}, {"line": 11, "start": 4, "end": 30}, {"line": 12, "start": 3, "end": 17}], "each-family": [{"line": 13, "start": 0, "end": 5}, {"line": 14, "start": 2, "end": 10}], "each-child": [{"line": 15, "start": 2, "end": 12}, {"line": 16, "start": 2, "end": 43}], "family-ID": [{"line": 1, "start": 2, "end": 8}]}, "source": "SELECT \n  family,\n  ('child' || child) AS child,\n  (CASE child \n    WHEN 1 THEN dob_child1 \n    WHEN 2 THEN dob_child2 \n    WHEN 3 THEN dob_child3 \n   END) AS dob,\n  (CASE child \n    WHEN 1 THEN height_child1 \n    WHEN 2 THEN height_child2 \n    WHEN 3 THEN height_child3 \n   END) AS height\nFROM \n  families\n  CROSS JOIN\n  (SELECT 1 as child UNION VALUES (2), (3))", "author": "will", "implementation": ""}, {"task": "row_per_child", "language": "datalog", "plan": {"each-family": [{"line": 1, "start": 2, "end": 11}, {"line": 1, "start": 42, "end": 43}, {"line": 3, "start": 2, "end": 11}, {"line": 3, "start": 42, "end": 43}, {"line": 5, "start": 2, "end": 11}, {"line": 5, "start": 42, "end": 43}], "each-child": [{"line": 0, "start": 0, "end": 47}, {"line": 2, "start": 0, "end": 47}, {"line": 4, "start": 0, "end": 47}], "family-ID": [{"line": 1, "start": 22, "end": 28}, {"line": 3, "start": 22, "end": 28}, {"line": 5, "start": 22, "end": 28}], "child-ID": [{"line": 0, "start": 14, "end": 22}, {"line": 2, "start": 14, "end": 22}, {"line": 4, "start": 14, "end": 22}], "dob-height": [{"line": 1, "start": 11, "end": 14}, {"line": 1, "start": 30, "end": 36}, {"line": 3, "start": 14, "end": 17}, {"line": 3, "start": 33, "end": 39}, {"line": 5, "start": 17, "end": 20}, {"line": 5, "start": 36, "end": 42}]}, "source": "row_per_child(\"child1\", dob, family, height) :-\n  families(dob, _, _, family, height, _, _).\nrow_per_child(\"child2\", dob, family, height) :-\n  families(_, dob, _, family, _, height, _).\nrow_per_child(\"child3\", dob, family, height) :-\n  families(_, _, dob, family, _, _, height).", "author": "will", "implementation": ""}, {"task": "row_per_child", "language": "q", "plan": {"each-family": [{"line": 1, "start": 8, "end": 28}, {"line": 2, "start": 63, "end": 64}], "each-child": [{"line": 5, "start": 15, "end": 51}, {"line": 0, "start": 0, "end": 20}, {"line": 3, "start": 66, "end": 67}], "family-ID": [{"line": 2, "start": 5, "end": 13}], "dob-height": [{"line": 2, "start": 14, "end": 62}], "child-ID": [{"line": 3, "start": 2, "end": 66}]}, "source": "child_rows: {[child] \n  rows: ?[families; (); 0b; `family`dob`height ! \n    (`family; `$(\"dob_child\",child); `$(\"height_child\", child))];\n  update child: (count families)#enlist (\"child\", child) from rows}\n      \nrow_per_child: (child_rows each (\"1\"; \"2\"; \"3\")) ,/;", "author": "will", "implementation": ""}, {"task": "row_per_child", "language": "python-functional", "plan": {"each-family": [{"line": 6, "start": 4, "end": 26}], "each-child": [{"line": 7, "start": 4, "end": 22}], "family-ID": [{"line": 2, "start": 5, "end": 32}], "child-ID": [{"line": 3, "start": 5, "end": 26}], "dob-height": [{"line": 4, "start": 5, "end": 36}, {"line": 5, "start": 5, "end": 41}]}, "source": "def row_per_child(families):\n  return [\n    {'family': family['family'],\n     'child': f'child{i}',\n     'dob': family[f'dob_child{i}'],\n     'height': family[f'height_child{i}']}\n    for family in families    \n    for i in [1, 2, 3]\n  ]", "author": "will", "implementation": ""}, {"task": "row_per_child", "language": "python-imperative", "plan": {"each-family": [{"line": 3, "start": 2, "end": 25}], "family-ID": [{"line": 6, "start": 8, "end": 35}], "each-child": [{"line": 4, "start": 4, "end": 23}, {"line": 5, "start": 6, "end": 23}, {"line": 10, "start": 6, "end": 8}], "child-ID": [{"line": 7, "start": 8, "end": 29}], "dob-height": [{"line": 8, "start": 8, "end": 39}, {"line": 9, "start": 8, "end": 44}]}, "source": "\ndef row_per_child(families):\n  children = []\n  for family in families:\n    for i in [1, 2, 3]:\n      children.append({\n        'family': family['family'],\n        'child': f'child{i}',\n        'dob': family[f'dob_child{i}'],\n        'height': family[f'height_child{i}']\n      })\n  return children\n", "author": "will", "implementation": ""}, {"task": "row_per_child", "language": "r", "plan": {"each-family": [{"line": 1, "start": 2, "end": 14}], "family-ID": [{"line": 3, "start": 6, "end": 13}], "each-child": [{"line": 4, "start": 6, "end": 38}, {"line": 5, "start": 6, "end": 22}], "child-ID": [{"line": 2, "start": 4, "end": 17}, {"line": 6, "start": 4, "end": 5}], "dob-height": [{"line": 2, "start": 4, "end": 17}, {"line": 6, "start": 4, "end": 5}]}, "source": "row_per_child <- function(families) {\n  families %>%\n    pivot_longer(\n      !family,\n      names_to = c(\".value\", \"child\"),\n      names_sep = \"_\",\n    )\n}", "author": "will", "implementation": ""}, {"task": "rolling_average", "language": "sql", "plan": {"windows": [{"line": 2, "start": 0, "end": 16}, {"line": 0, "start": 0, "end": 6}, {"line": 1, "start": 0, "end": 21}], "group": [{"line": 3, "start": 0, "end": 18}, {"line": 4, "start": 0, "end": 29}, {"line": 5, "start": 3, "end": 28}, {"line": 6, "start": 0, "end": 17}], "filter": [{"line": 1, "start": 23, "end": 46}]}, "source": "SELECT\nend.time as end_time,  AVG(other.x) as average\nFROM data as end\nJOIN data as other\nON other.time <= end.time and\n   other.time > end.time - 7\nGROUP BY end.time", "author": "scott", "implementation": ""}, {"task": "rolling_average", "language": "python-imperative", "plan": {"windows": [{"line": 3, "start": 2, "end": 34}, {"line": 2, "start": 2, "end": 13}, {"line": 10, "start": 4, "end": 18}, {"line": 11, "start": 6, "end": 23}, {"line": 14, "start": 2, "end": 15}], "group": [{"line": 6, "start": 4, "end": 30}, {"line": 7, "start": 6, "end": 36}, {"line": 8, "start": 8, "end": 13}, {"line": 1, "start": 2, "end": 36}, {"line": 4, "start": 4, "end": 23}], "filter": [{"line": 9, "start": 6, "end": 39}, {"line": 5, "start": 4, "end": 25}, {"line": 12, "start": 7, "end": 31}]}, "source": "def rolling_average(data):\n  data.sort(key=lambda v: v[\"time\"])\n  result = []\n  for i, value in enumerate(data):\n    end = value[\"time\"]\n    total, count = 0.0, 0\n    for j in range(i, -1, -1):\n      if data[j][\"time\"] <= end - 7:\n        break\n      total += data[j][\"x\"]; count += 1\n    result.append(\n      {\"end_time\": end,\n       \"average\": total / count}\n    )\n  return result", "author": "scott", "implementation": ""}, {"task": "rolling_average", "language": "python-functional", "plan": {"filter": [{"line": 3, "start": 5, "end": 34}], "windows": [{"line": 4, "start": 4, "end": 17}, {"line": 1, "start": 2, "end": 10}, {"line": 2, "start": 4, "end": 27}], "group": [{"line": 6, "start": 7, "end": 27}, {"line": 7, "start": 14, "end": 43}, {"line": 8, "start": 17, "end": 42}, {"line": 5, "start": 8, "end": 10}]}, "source": "def rolling_average(data):\n  return [\n    {\"end_time\": x[\"time\"],\n     \"average\": sum(vs) / len(vs)}\n    for x in data\n    for vs in [\n      [y[\"x\"] for y in data\n              if y[\"time\"] <= x[\"time\"] and\n                 y[\"time\"] > x[\"time\"] - 7]\n    ]\n  ]", "author": "scott", "implementation": ""}, {"task": "rolling_average", "language": "python-pandas", "plan": {"filter": [{"line": 5, "start": 36, "end": 42}, {"line": 9, "start": 5, "end": 37}], "group": [{"line": 5, "start": 15, "end": 35}, {"line": 3, "start": 2, "end": 47}], "windows": [{"line": 4, "start": 2, "end": 52}, {"line": 1, "start": 2, "end": 17}, {"line": 7, "start": 2, "end": 32}, {"line": 8, "start": 4, "end": 58}]}, "source": "def rolling_average(data):\n  d = data.copy()\n\n  data.time = pd.to_datetime(data.time * 10**9)\n  data = (data.sort_values('time').set_index('time')\n              .rolling(window='7s').mean())\n\n  return pd.DataFrame.from_dict(\n    {'end_time': d.sort_values('time').reset_index().time,\n     'average': data.reset_index().x}\n  )", "author": "scott", "implementation": ""}, {"task": "rolling_average", "language": "datalog", "plan": {"group": [{"line": 0, "start": 0, "end": 44}, {"line": 1, "start": 0, "end": 22}, {"line": 2, "start": 2, "end": 32}, {"line": 3, "start": 2, "end": 34}, {"line": 6, "start": 31, "end": 50}, {"line": 7, "start": 31, "end": 50}], "filter": [{"line": 6, "start": 2, "end": 15}, {"line": 7, "start": 6, "end": 15}, {"line": 8, "start": 0, "end": 31}, {"line": 9, "start": 2, "end": 44}, {"line": 7, "start": 52, "end": 59}], "windows": [{"line": 5, "start": 30, "end": 47}, {"line": 9, "start": 2, "end": 17}, {"line": 4, "start": 0, "end": 54}, {"line": 5, "start": 0, "end": 26}, {"line": 6, "start": 19, "end": 29}, {"line": 7, "start": 19, "end": 29}]}, "source": ".decl window(end_time: number, time: number)\nwindow(end_time, t) :-\n  data(end_time, _), data(t, _),\n  t <= end_time, t > end_time - 7.\n.decl bucket(end_time: number, total: float, n: float)\nbucket(end_time, total, n) :- data(end_time, _),\n  total = sum v : {data(t, v), window(end_time, t)},\n      n = sum z : {data(t, _), window(end_time, t), z = 1.0}.\nrolling_average(end_time, v) :-\n  bucket(end_time, total, n), v = total / n.", "author": "scott", "implementation": ""}, {"task": "rolling_average", "language": "r", "plan": {"group": [{"line": 3, "start": 59, "end": 72}, {"line": 3, "start": 10, "end": 47}], "filter": [{"line": 3, "start": 48, "end": 59}, {"line": 3, "start": 2, "end": 10}, {"line": 4, "start": 35, "end": 49}, {"line": 4, "start": 72, "end": 79}]}, "source": "library(slider)\nrolling_average <- function(data) {\n  data <- arrange(data, time)\n  avgs <- unlist(slide_index(data$x, data$time, ~ mean(.x), .before = 6))\n  data %>% mutate(end_time = time, average = avgs) %>% select(end_time, average)\n}", "author": "scott", "implementation": ""}, {"task": "rolling_average", "language": "q", "plan": {"filter": [{"line": 1, "start": 15, "end": 21}, {"line": 3, "start": 25, "end": 48}, {"line": 1, "start": 8, "end": 15}], "group": [{"line": 1, "start": 22, "end": 61}], "windows": [{"line": 3, "start": 49, "end": 58}, {"line": 3, "start": 2, "end": 23}]}, "source": "get_avg: \n  {[t] (select avg(x) from data where time within (t - 6; t)) `x};\nrolling_average: \n  select end_time: time, average: get_avg'[time] from data", "author": "scott", "implementation": ""}, {"task": "unique_beer_drinkers", "language": "python-pandas", "plan": {"iter": [{"line": 1, "start": 22, "end": 27}, {"line": 2, "start": 4, "end": 20}, {"line": 1, "start": 2, "end": 22}, {"line": 11, "start": 1, "end": 37}, {"line": 12, "start": 52, "end": 53}, {"line": 13, "start": 2, "end": 38}], "collect": [{"line": 3, "start": 4, "end": 27}, {"line": 4, "start": 4, "end": 18}, {"line": 1, "start": 2, "end": 22}], "compare": [{"line": 6, "start": 2, "end": 28}, {"line": 7, "start": 4, "end": 36}, {"line": 8, "start": 6, "end": 43}, {"line": 9, "start": 4, "end": 55}, {"line": 12, "start": 4, "end": 52}]}, "source": "def unique_beer_drinkers(likes):\n  likes_per_person = (likes\n    .groupby('name')\n    .beer.unique().map(set)\n    .reset_index())\n\n  def check_not_exists(row):\n    other_people = likes_per_person[\n      likes_per_person.name != row['name']]\n    return not (other_people.beer == row['beer']).any()\n  \n  unique_drinkers = likes_per_person[\n    likes_per_person.apply(check_not_exists, axis=1)]\n  return unique_drinkers.name.tolist()", "author": "will", "implementation": ""}, {"task": "unique_beer_drinkers", "language": "datalog", "plan": {"iter": [{"line": 11, "start": 21, "end": 25}, {"line": 12, "start": 2, "end": 17}], "compare": [{"line": 13, "start": 2, "end": 20}, {"line": 4, "start": 0, "end": 27}, {"line": 5, "start": 0, "end": 20}, {"line": 7, "start": 2, "end": 18}, {"line": 8, "start": 2, "end": 16}, {"line": 6, "start": 2, "end": 18}, {"line": 9, "start": 2, "end": 23}, {"line": 1, "start": 0, "end": 16}, {"line": 1, "start": 30, "end": 61}, {"line": 2, "start": 0, "end": 46}, {"line": 0, "start": 0, "end": 32}], "collect": [{"line": 1, "start": 16, "end": 30}, {"line": 2, "start": 46, "end": 60}]}, "source": ".decl differ(a:symbol, b:symbol)\ndiffer(A, B) :- likes(Beer, A), likes(_, B), !likes(Beer, B).\ndiffer(A, B) :- likes(_, A), likes(Beer, B), !likes(Beer, A).\n\n.decl exists_same(a:symbol)\nexists_same(Name) :- \n  likes(_, Other), \n  likes(_, Name), \n  Name != Other, \n  !differ(Name, Other).\n\nunique_beer_drinkers(Name) :- \n  likes(_, Name), \n  !exists_same(Name).", "author": "will", "implementation": "neg_exist"}, {"task": "unique_beer_drinkers", "language": "sql", "plan": {"iter": [{"line": 0, "start": 0, "end": 23}, {"line": 1, "start": 0, "end": 13}], "compare": [{"line": 2, "start": 0, "end": 17}, {"line": 23, "start": 34, "end": 35}, {"line": 3, "start": 4, "end": 12}, {"line": 4, "start": 4, "end": 17}, {"line": 5, "start": 4, "end": 28}, {"line": 6, "start": 4, "end": 19}, {"line": 7, "start": 8, "end": 16}, {"line": 8, "start": 8, "end": 21}, {"line": 9, "start": 8, "end": 31}, {"line": 10, "start": 8, "end": 23}, {"line": 14, "start": 12, "end": 35}, {"line": 15, "start": 4, "end": 19}, {"line": 19, "start": 8, "end": 23}, {"line": 20, "start": 12, "end": 20}, {"line": 21, "start": 12, "end": 25}, {"line": 22, "start": 12, "end": 35}, {"line": 23, "start": 12, "end": 35}], "collect": [{"line": 11, "start": 12, "end": 20}, {"line": 12, "start": 12, "end": 25}, {"line": 13, "start": 12, "end": 35}, {"line": 16, "start": 8, "end": 16}, {"line": 17, "start": 8, "end": 21}, {"line": 18, "start": 8, "end": 31}]}, "source": "SELECT DISTINCT L1.name\nFROM likes L1\nWHERE NOT EXISTS(\n    SELECT *\n    FROM likes L2\n    WHERE L1.name != L2.name\n    AND NOT EXISTS(\n        SELECT *\n        FROM likes L3\n        WHERE L3.name = L2.name\n        AND NOT EXISTS(\n            SELECT *\n            FROM likes L4\n            WHERE L4.name = L1.name\n            AND L4.beer = L3.beer))\n    AND NOT EXISTS(\n        SELECT *\n        FROM likes L5\n        WHERE L5.name = L1.name\n        AND NOT EXISTS(\n            SELECT *\n            FROM likes L6\n            WHERE L6.name = L2.name\n            AND L6.beer= L5.beer)))", "author": "will", "implementation": ""}, {"task": "unique_beer_drinkers", "language": "q", "plan": {"collect": [{"line": 0, "start": 0, "end": 37}], "compare": [{"line": 1, "start": 0, "end": 42}, {"line": 3, "start": 43, "end": 68}], "iter": [{"line": 3, "start": 3, "end": 42}, {"line": 4, "start": 2, "end": 7}]}, "source": "likes_per_person: `name xgroup likes;\ncounts: count each group likes_per_person;\nunique_beer_drinkers: \n  (select name from likes_per_person where beer in\\: where[counts=1])\n  `name", "author": "will", "implementation": ""}, {"task": "unique_beer_drinkers", "language": "python-functional", "plan": {"iter": [{"line": 1, "start": 2, "end": 46}, {"line": 4, "start": 4, "end": 22}, {"line": 5, "start": 2, "end": 3}, {"line": 2, "start": 2, "end": 22}, {"line": 3, "start": 4, "end": 9}, {"line": 7, "start": 2, "end": 10}, {"line": 8, "start": 4, "end": 8}, {"line": 9, "start": 4, "end": 13}, {"line": 9, "start": 20, "end": 47}, {"line": 14, "start": 2, "end": 3}], "collect": [{"line": 3, "start": 10, "end": 68}, {"line": 9, "start": 13, "end": 47}], "compare": [{"line": 10, "start": 4, "end": 16}, {"line": 11, "start": 6, "end": 49}, {"line": 12, "start": 6, "end": 61}, {"line": 13, "start": 4, "end": 6}]}, "source": "def unique_beer_drinkers(likes):\n  people = set([row['name'] for row in likes])\n  likes_per_person = {\n    name: set([row['beer'] for row in likes if row['name'] == name])\n    for name in people\n  }\n    \n  return [\n    name\n    for name, beers in likes_per_person.items()\n    if not any([\n      other_name != name and beers == other_beers\n      for other_name, other_beers in likes_per_person.items()\n    ])\n  ]", "author": "will", "implementation": ""}, {"task": "unique_beer_drinkers", "language": "python-imperative", "plan": {"collect": [{"line": 1, "start": 21, "end": 37}, {"line": 3, "start": 33, "end": 50}, {"line": 6, "start": 10, "end": 47}, {"line": 18, "start": 2, "end": 15}], "iter": [{"line": 2, "start": 2, "end": 19}, {"line": 3, "start": 4, "end": 33}, {"line": 5, "start": 2, "end": 13}, {"line": 6, "start": 2, "end": 9}, {"line": 6, "start": 19, "end": 47}], "compare": [{"line": 7, "start": 4, "end": 20}, {"line": 8, "start": 4, "end": 49}, {"line": 9, "start": 6, "end": 18}, {"line": 10, "start": 8, "end": 16}, {"line": 12, "start": 6, "end": 30}, {"line": 13, "start": 8, "end": 25}, {"line": 14, "start": 8, "end": 13}, {"line": 15, "start": 4, "end": 17}, {"line": 16, "start": 6, "end": 23}]}, "source": "def unique_beer_drinkers(likes):\n  likes_per_person = defaultdict(set)\n  for row in likes:\n    likes_per_person[row['name']].add(row['beer'])\n    \n  unique = []\n  for p1, p1_likes in likes_per_person.items():\n    is_unique = True\n    for p2, p2_likes in likes_per_person.items():\n      if p1 == p2:\n        continue\n        \n      if p1_likes == p2_likes:\n        is_unique = False\n        break\n    if is_unique:\n      unique.append(p1)\n      \n  return unique", "author": "will", "implementation": ""}, {"task": "unique_beer_drinkers", "language": "r", "plan": {"iter": [{"line": 1, "start": 2, "end": 11}, {"line": 2, "start": 4, "end": 22}, {"line": 6, "start": 4, "end": 14}], "collect": [{"line": 3, "start": 4, "end": 54}], "compare": [{"line": 4, "start": 4, "end": 54}, {"line": 5, "start": 4, "end": 37}]}, "source": "unique_beer_drinkers <- function(likes) {\n  likes %>%\n    group_by(name) %>%\n    summarize(beer_set = list(sort(unique(beer)))) %>%\n    add_count(beer_set, name = 'num_people_likes') %>%\n    filter(num_people_likes == 1) %>%\n    pull(name)\n}", "author": "will", "implementation": ""}, {"task": "purchased_all_food", "language": "python-pandas", "plan": {"iter": [{"line": 2, "start": 21, "end": 27}, {"line": 3, "start": 4, "end": 21}, {"line": 6, "start": 2, "end": 25}, {"line": 6, "start": 50, "end": 64}], "all": [{"line": 1, "start": 2, "end": 20}, {"line": 6, "start": 25, "end": 50}], "ordered": [{"line": 2, "start": 2, "end": 21}, {"line": 4, "start": 4, "end": 19}, {"line": 5, "start": 4, "end": 14}]}, "source": "def purchased_all_food(food, orders):\n  n_food = len(food)\n  n_unique_orders = (orders\n    .groupby('buyer')\n    .food.unique() \n    .map(len))\n  return n_unique_orders[n_unique_orders == n_food].index.values", "author": "will", "implementation": ""}, {"task": "purchased_all_food", "language": "sql", "plan": {"iter": [{"line": 0, "start": 0, "end": 21}, {"line": 1, "start": 0, "end": 14}], "ordered": [{"line": 3, "start": 2, "end": 46}, {"line": 4, "start": 3, "end": 29}], "all": [{"line": 5, "start": 2, "end": 29}, {"line": 4, "start": 30, "end": 31}]}, "source": "SELECT DISTINCT buyer\nFROM orders o1\nWHERE \n  (SELECT COUNT(DISTINCT food) FROM orders o2 \n   WHERE o1.buyer = o2.buyer) = \n  (SELECT COUNT(*) FROM food)", "author": "will", "implementation": ""}, {"task": "purchased_all_food", "language": "datalog", "plan": {"ordered": [{"line": 0, "start": 0, "end": 46}, {"line": 1, "start": 0, "end": 53}, {"line": 6, "start": 2, "end": 52}], "all": [{"line": 5, "start": 2, "end": 30}, {"line": 7, "start": 2, "end": 27}], "iter": [{"line": 4, "start": 2, "end": 22}, {"line": 3, "start": 19, "end": 24}]}, "source": ".decl has_purchased(Buyer:symbol, Food:number)\nhas_purchased(Buyer, Food) :- orders(Buyer, Food, _).\n\npurchased_all_food(Buyer) :-\n  orders(Buyer, _, _),\n  N_food = count : food(_, _),\n  N_unique_orders = count : has_purchased(Buyer, _),\n  N_food = N_unique_orders.", "author": "will", "implementation": ""}, {"task": "purchased_all_food", "language": "q", "plan": {"iter": [{"line": 3, "start": 45, "end": 56}], "ordered": [{"line": 0, "start": 0, "end": 29}], "all": [{"line": 3, "start": 3, "end": 44}, {"line": 1, "start": 0, "end": 18}]}, "source": "buyers: `buyer xgroup orders;\ntotal: count food;\npurchased_all_food:\n  (where {(count distinct x[`food]) = total} each buyers) `buyer", "author": "will", "implementation": ""}, {"task": "purchased_all_food", "language": "python-functional", "plan": {"iter": [{"line": 2, "start": 4, "end": 54}, {"line": 4, "start": 8, "end": 13}, {"line": 5, "start": 8, "end": 27}], "all": [{"line": 1, "start": 4, "end": 22}, {"line": 7, "start": 43, "end": 52}, {"line": 6, "start": 8, "end": 10}], "ordered": [{"line": 6, "start": 11, "end": 54}, {"line": 7, "start": 13, "end": 42}]}, "source": "def purchased_all_food(food, orders):\n    n_food = len(food)\n    buyers = set([order[\"buyer\"] for order in orders])\n    return [\n        buyer\n        for buyer in buyers\n        if len(set([order[\"food\"] for order in orders \n             if order[\"buyer\"] == buyer])) == n_food\n    ]", "author": "will", "implementation": ""}, {"task": "purchased_all_food", "language": "python-imperative", "plan": {"all": [{"line": 1, "start": 2, "end": 20}, {"line": 8, "start": 4, "end": 29}], "ordered": [{"line": 2, "start": 2, "end": 34}, {"line": 3, "start": 2, "end": 22}, {"line": 4, "start": 4, "end": 18}, {"line": 4, "start": 32, "end": 52}, {"line": 7, "start": 13, "end": 45}], "iter": [{"line": 4, "start": 18, "end": 32}, {"line": 6, "start": 2, "end": 13}, {"line": 7, "start": 2, "end": 12}, {"line": 7, "start": 20, "end": 45}, {"line": 9, "start": 6, "end": 26}, {"line": 10, "start": 2, "end": 15}]}, "source": "def purchased_all_food(food, orders):\n  n_food = len(food)\n  unique_orders = defaultdict(set)\n  for order in orders:\n    unique_orders[order[\"buyer\"]].add(order[\"food\"])\n      \n  buyers = []\n  for buyer, orders in unique_orders.items():\n    if len(orders) == n_food:\n      buyers.append(buyer)\n  return buyers", "author": "will", "implementation": ""}, {"task": "purchased_all_food", "language": "r", "plan": {"iter": [{"line": 2, "start": 2, "end": 12}, {"line": 3, "start": 4, "end": 23}, {"line": 7, "start": 4, "end": 14}], "ordered": [{"line": 4, "start": 4, "end": 22}], "all": [{"line": 5, "start": 4, "end": 15}, {"line": 6, "start": 4, "end": 27}, {"line": 1, "start": 2, "end": 23}]}, "source": "purchased_all_food <- function(food, orders) {\n  n_food <- count(food)    \n  orders %>%\n    group_by(buyer) %>%\n    distinct(food) %>%\n    count() %>%\n    filter(n == n_food) %>%\n    pull(buyer)\n}", "author": "will", "implementation": ""}, {"task": "customer_orders", "language": "python-imperative", "plan": {"order_ids": [{"line": 7, "start": 22, "end": 34}], "California": [{"line": 6, "start": 8, "end": 48}], "customer": [{"line": 4, "start": 4, "end": 30}]}, "source": "  \ndef customer_orders(customers,orders):\n  oids = []\n  for order in orders:\n    for customer in customers:\n      if customer['cid'] == order['cid']:\n        if customer['location'] == \"California\":\n          oids.append(order['oid'])\n  return oids\n", "author": "g", "implementation": ""}, {"task": "customer_orders", "language": "python-pandas", "plan": {"order_ids": [{"line": 4, "start": 9, "end": 28}], "California": [{"line": 3, "start": 22, "end": 56}], "customer": [{"line": 2, "start": 23, "end": 42}]}, "source": "  \ndef customer_orders(customers,orders):\n  joined = orders.join(customers, on=\"cid\",how=\"inner\",lsuffix=\"_j\")\n  joined = joined.loc[joined['location'] == \"California\"]\n  return joined.oid.tolist()\n\n", "author": "g", "implementation": ""}, {"task": "customer_orders", "language": "r", "plan": {"order_ids": [{"line": 4, "start": 4, "end": 13}, {"line": 3, "start": 4, "end": 38}], "customer": [{"line": 1, "start": 2, "end": 15}], "California": [{"line": 2, "start": 4, "end": 40}]}, "source": "customer_orders <- function(customers, orders) {\n  customers %>%\n    filter(location == \"California\") %>%\n    inner_join(orders, by = \"cid\") %>%\n    pull(oid)\n}", "author": "g", "implementation": ""}, {"task": "customer_orders", "language": "q", "plan": {"order_ids": [{"line": 1, "start": 3, "end": 25}, {"line": 2, "start": 35, "end": 39}], "California": [{"line": 2, "start": 2, "end": 33}], "customer": [{"line": 1, "start": 26, "end": 50}]}, "source": "customer_orders: {[customers; orders]\n  (select oid from orders ij (`cid xkey customers) \n  where location ~\\: \"California\") `oid}", "author": "g", "implementation": ""}, {"task": "customer_orders", "language": "sql", "plan": {"California": [{"line": 5, "start": 0, "end": 27}], "order_ids": [{"line": 1, "start": 0, "end": 18}], "customer": [{"line": 3, "start": 1, "end": 31}, {"line": 4, "start": 0, "end": 26}]}, "source": "  \nSELECT orders.oid \nFROM \n(orders INNER JOIN customers ON\norders.cid = customers.cid) \nWHERE location=\"California\"\n", "author": "g", "implementation": ""}, {"task": "customer_orders", "language": "datalog", "plan": {"California": [{"line": 2, "start": 25, "end": 37}], "customer": [{"line": 2, "start": 2, "end": 24}], "order_ids": [{"line": 3, "start": 15, "end": 18}]}, "source": "  \ncustomer_orders(oid):-\n  customers(cid,customer,\"California\"),\n  orders(cid,_,oid,_).\n", "author": "g", "implementation": ""}, {"task": "customer_orders", "language": "python-functional", "plan": {"order_ids": [{"line": 5, "start": 10, "end": 42}], "California": [{"line": 4, "start": 4, "end": 43}], "customer": [{"line": 3, "start": 10, "end": 51}, {"line": 6, "start": 7, "end": 27}]}, "source": "  \ndef customer_orders(customers,orders):\n  oids = []\n  cids = [customer['cid'] for customer in customers\n    if customer['location'] == \"California\"]\n  oids = [order['oid'] for order in orders \n    if order['cid'] in cids]\n  return oids\n", "author": "g", "implementation": ""}, {"task": "changing_mean", "language": "python-imperative", "plan": {"remove": [{"line": 10, "start": 4, "end": 34}], "new": [{"line": 1, "start": 0, "end": 17}, {"line": 2, "start": 2, "end": 9}, {"line": 3, "start": 2, "end": 14}, {"line": 4, "start": 4, "end": 21}, {"line": 5, "start": 2, "end": 20}, {"line": 11, "start": 4, "end": 27}, {"line": 1, "start": 0, "end": 17}, {"line": 2, "start": 2, "end": 9}, {"line": 3, "start": 2, "end": 14}, {"line": 4, "start": 4, "end": 21}, {"line": 1, "start": 0, "end": 17}, {"line": 2, "start": 2, "end": 9}, {"line": 3, "start": 2, "end": 14}, {"line": 4, "start": 4, "end": 21}, {"line": 5, "start": 2, "end": 20}, {"line": 1, "start": 0, "end": 17}, {"line": 2, "start": 2, "end": 9}, {"line": 3, "start": 2, "end": 14}, {"line": 4, "start": 4, "end": 21}, {"line": 5, "start": 2, "end": 20}], "diff": [{"line": 12, "start": 4, "end": 36}], "orig": [{"line": 8, "start": 2, "end": 29}, {"line": 1, "start": 0, "end": 17}, {"line": 2, "start": 2, "end": 9}, {"line": 3, "start": 2, "end": 14}, {"line": 4, "start": 4, "end": 21}, {"line": 5, "start": 2, "end": 20}, {"line": 1, "start": 0, "end": 17}, {"line": 2, "start": 2, "end": 9}, {"line": 3, "start": 2, "end": 14}, {"line": 4, "start": 4, "end": 21}, {"line": 5, "start": 2, "end": 20}, {"line": 1, "start": 0, "end": 17}, {"line": 2, "start": 2, "end": 9}, {"line": 3, "start": 2, "end": 14}, {"line": 4, "start": 4, "end": 21}, {"line": 5, "start": 2, "end": 20}, {"line": 1, "start": 0, "end": 17}, {"line": 2, "start": 2, "end": 9}, {"line": 3, "start": 2, "end": 14}, {"line": 4, "start": 4, "end": 21}, {"line": 5, "start": 2, "end": 20}, {"line": 1, "start": 0, "end": 17}, {"line": 2, "start": 2, "end": 9}, {"line": 3, "start": 2, "end": 14}, {"line": 4, "start": 4, "end": 21}, {"line": 5, "start": 2, "end": 20}, {"line": 1, "start": 0, "end": 17}, {"line": 2, "start": 2, "end": 9}, {"line": 3, "start": 2, "end": 14}, {"line": 4, "start": 4, "end": 21}, {"line": 5, "start": 2, "end": 20}, {"line": 1, "start": 0, "end": 17}, {"line": 2, "start": 2, "end": 9}, {"line": 3, "start": 2, "end": 14}, {"line": 4, "start": 4, "end": 21}, {"line": 5, "start": 2, "end": 20}, {"line": 1, "start": 0, "end": 17}, {"line": 2, "start": 2, "end": 9}, {"line": 3, "start": 2, "end": 14}, {"line": 4, "start": 4, "end": 21}, {"line": 5, "start": 2, "end": 20}, {"line": 1, "start": 0, "end": 17}, {"line": 2, "start": 2, "end": 9}, {"line": 3, "start": 2, "end": 14}, {"line": 4, "start": 4, "end": 21}, {"line": 5, "start": 2, "end": 20}, {"line": 1, "start": 0, "end": 17}, {"line": 2, "start": 2, "end": 9}, {"line": 3, "start": 2, "end": 14}, {"line": 4, "start": 4, "end": 21}, {"line": 5, "start": 2, "end": 20}, {"line": 1, "start": 0, "end": 17}, {"line": 2, "start": 2, "end": 9}], "first": [{"line": 13, "start": 6, "end": 14}, {"line": 14, "start": 2, "end": 13}]}, "source": "\ndef get_mean(ls):\n  sum = 0\n  for e in ls:\n    sum += e['value']\n  return sum/len(ls)\n\ndef changing_mean(vals):\n  start_mean = get_mean(vals)\n  for i,elem in enumerate(vals):\n    new_ls = vals[:i] + vals[i+1:]\n    mean = get_mean(new_ls)\n    if abs(mean - start_mean) < 0.1:\n      return i\n  return None\n", "author": "g", "implementation": ""}, {"task": "changing_mean", "language": "python-pandas", "plan": {"diff": [{"line": 4, "start": 14, "end": 47}], "new": [{"line": 3, "start": 2, "end": 85}, {"line": 4, "start": 9, "end": 60}], "orig": [{"line": 2, "start": 2, "end": 26}], "remove": [{"line": 4, "start": 9, "end": 60}, {"line": 3, "start": 45, "end": 63}], "first": [{"line": 4, "start": 9, "end": 60}]}, "source": "\ndef changing_mean(vals):\n  mean = vals.value.mean()\n  mean_without = vals.apply(lambda row: vals[vals.id != row.id].value.mean(), axis=1)\n  return vals[(mean_without - mean).abs() < 0.1].id.tolist()\n", "author": "g", "implementation": ""}, {"task": "changing_mean", "language": "r", "plan": {"remove": [{"line": 4, "start": 43, "end": 65}], "orig": [{"line": 4, "start": 38, "end": 43}, {"line": 4, "start": 65, "end": 66}, {"line": 4, "start": 24, "end": 35}, {"line": 2, "start": 3, "end": 34}], "new": [{"line": 4, "start": 36, "end": 37}, {"line": 4, "start": 5, "end": 24}, {"line": 4, "start": 66, "end": 68}], "first": [{"line": 7, "start": 5, "end": 29}, {"line": 8, "start": 5, "end": 13}, {"line": 3, "start": 3, "end": 16}, {"line": 5, "start": 5, "end": 17}], "diff": [{"line": 6, "start": 5, "end": 34}]}, "source": "library(data.table)\nchanging_mean <- function(vals) {\n   global_mean <- mean(vals$value)\n   setDT(vals)[, \n     mean_change := abs(global_mean - mean(vals[id != .BY, value])), \n     by = id] %>%\n     filter(mean_change < 0.1) %>%\n     slice(which.min(id)) %>%\n     pull(id)\n}", "author": "g", "implementation": ""}, {"task": "changing_mean", "language": "q", "plan": {"remove": [{"line": 1, "start": 44, "end": 64}], "orig": [{"line": 1, "start": 7, "end": 23}, {"line": 1, "start": 26, "end": 43}], "new": [{"line": 1, "start": 3, "end": 6}, {"line": 1, "start": 23, "end": 26}], "diff": [{"line": 4, "start": 31, "end": 48}], "first": [{"line": 4, "start": 15, "end": 20}, {"line": 4, "start": 20, "end": 30}]}, "source": "diffs: \n  {abs avg vals[`value] - avg (vals[`value] where vals[`id] <> x)} \n  each vals[`id];\n  \nchanging_mean: first vals[`id] where diffs < 0.1", "author": "g", "implementation": ""}, {"task": "changing_mean", "language": "sql", "plan": {"diff": [{"line": 6, "start": 35, "end": 40}, {"line": 2, "start": 6, "end": 11}], "new": [{"line": 3, "start": 2, "end": 19}, {"line": 4, "start": 2, "end": 14}, {"line": 5, "start": 2, "end": 22}, {"line": 2, "start": 6, "end": 11}, {"line": 3, "start": 2, "end": 19}, {"line": 4, "start": 2, "end": 14}, {"line": 5, "start": 2, "end": 22}, {"line": 6, "start": 0, "end": 34}], "orig": [{"line": 6, "start": 5, "end": 32}], "remove": [{"line": 5, "start": 2, "end": 22}, {"line": 5, "start": 2, "end": 22}], "first": [{"line": 0, "start": 0, "end": 9}]}, "source": "SELECT id\nFROM vals v1\nWHERE ABS((\n  SELECT AVG(value)\n  FROM vals v2\n  WHERE v1.id != v2.id\n) - (SELECT AVG(value) FROM vals)) < 0.1", "author": "g", "implementation": ""}, {"task": "changing_mean", "language": "datalog", "plan": {"orig": [{"line": 9, "start": 2, "end": 27}, {"line": 10, "start": 2, "end": 29}, {"line": 11, "start": 2, "end": 18}], "new": [{"line": 12, "start": 2, "end": 27}, {"line": 1, "start": 0, "end": 22}, {"line": 2, "start": 2, "end": 13}, {"line": 3, "start": 2, "end": 39}, {"line": 4, "start": 2, "end": 41}, {"line": 5, "start": 2, "end": 18}], "diff": [{"line": 13, "start": 2, "end": 44}, {"line": 14, "start": 3, "end": 45}], "first": [{"line": 8, "start": 7, "end": 8}], "remove": [{"line": 3, "start": 2, "end": 39}, {"line": 4, "start": 2, "end": 41}]}, "source": ".decl avg_except(I:number, Avg:float)    \navg_except(I, Avg) :- \n  vals(I, _),\n  N = sum 1.0 : { vals(J, _), I != J },\n  Total = sum V : { vals(J, V), I != J },\n  Avg = Total / N.\n  \nchanging_mean(I) :-\n  vals(I, _),\n  N = sum 1.0 : vals(_, _),\n  Total = sum V : vals(_, V),\n  Avg = Total / N,\n  avg_except(I, AvgExcept),\n  ((Avg > AvgExcept, Avg - AvgExcept < 0.1);\n   (Avg < AvgExcept, AvgExcept - Avg < 0.1)).", "author": "g", "implementation": ""}, {"task": "changing_mean", "language": "python-functional", "plan": {"remove": [{"line": 6, "start": 4, "end": 52}], "diff": [{"line": 8, "start": 4, "end": 35}, {"line": 3, "start": 2, "end": 34}], "new": [{"line": 6, "start": 4, "end": 52}, {"line": 7, "start": 4, "end": 34}, {"line": 1, "start": 0, "end": 24}, {"line": 2, "start": 2, "end": 56}, {"line": 3, "start": 2, "end": 34}], "orig": [{"line": 2, "start": 2, "end": 56}, {"line": 1, "start": 0, "end": 24}], "first": [{"line": 9, "start": 6, "end": 14}, {"line": 10, "start": 2, "end": 13}]}, "source": "\ndef changing_mean(vals):\n  start_mean = sum([l['value'] for l in vals])/len(vals)\n  diff = lambda m, sm: abs(m - sm)\n    \n  for i,elem in enumerate(vals):\n    new_ls = [x['value'] for x in vals if x != elem]\n    mean = sum(new_ls)/len(new_ls)\n    if diff(mean,start_mean) < 0.1:\n      return i\n  return None\n", "author": "g", "implementation": ""}, {"task": "exists_unique", "language": "python-imperative", "plan": {}, "source": "\ndef exists_unique(list):\n    values = [l[\"value\"] for l in list]\n    for elem in values:\n        if values.count(elem) == 1:\n            return 1\n    return 0\n", "author": "g", "implementation": ""}, {"task": "exists_unique", "language": "python-pandas", "plan": {}, "source": "\ndef exists_unique(list):\n    values = list.value.value_counts()\n    for val in values:\n        if val == 1:\n            return 1\n    return 0\n", "author": "g", "implementation": ""}, {"task": "exists_unique", "language": "sql", "plan": {}, "source": "\n    SELECT CASE WHEN EXISTS (\n    SELECT value\n    FROM list\n    GROUP BY value\n    HAVING Count(*) == 1\n    )\n    THEN CAST(1 AS INT)\n    ELSE CAST(0 AS INT)\n    END\n", "author": "g", "implementation": ""}, {"task": "exists_unique", "language": "datalog", "plan": {}, "source": "\n.decl is_unique(Value:number)\nis_unique(Value) :-\nlist(_,Value), !not_unique(Value).\n.decl not_unique(Value:number)\nnot_unique(Value) :- list(Id1,Value), list(Id2,Value), Id1 != Id2.\n\nexists_unique(Value):-\n(is_unique(_),Value=1);\n(!is_unique(_),Value=0).\n\n", "author": "g", "implementation": ""}, {"task": "exists_unique", "language": "python-functional", "plan": {}, "source": "\ndef exists_unique(list):\n    values = [l[\"value\"] for l in list]\n    return int(any(values.count(x) == 1 for x in values))\n", "author": "g", "implementation": ""}, {"task": "scc", "language": "sql", "plan": {"vertices": [{"line": 1, "start": 0, "end": 23}], "edge_match": [{"line": 6, "start": 2, "end": 30}], "edge_sequence": [{"line": 4, "start": 2, "end": 33}, {"line": 5, "start": 2, "end": 41}], "source<->target": [{"line": 11, "start": 2, "end": 62}, {"line": 10, "start": 2, "end": 44}, {"line": 14, "start": 0, "end": 33}, {"line": 8, "start": 0, "end": 22}, {"line": 9, "start": 2, "end": 33}, {"line": 13, "start": 0, "end": 31}], "graph": [{"line": 2, "start": 2, "end": 43}]}, "source": "WITH RECURSIVE\nclosure(source, target) AS (\n  SELECT DISTINCT source, target FROM graph\n  UNION\n  SELECT edge.source, path.target\n  FROM closure as path JOIN graph as edge\n  ON edge.target = path.source\n),\ncomponent(v1, v2) AS (\n  SELECT path.source, path.target\n  FROM closure as path JOIN closure as path_\n  ON path.source = path_.target AND path.target = path_.source\n)\nSELECT S.v2 FROM component as S\nJOIN query ON S.v1 = query.source", "author": "scott", "implementation": ""}, {"task": "scc", "language": "python-imperative", "plan": {"graph": [{"line": 2, "start": 2, "end": 18}, {"line": 5, "start": 4, "end": 32}, {"line": 6, "start": 4, "end": 32}, {"line": 3, "start": 2, "end": 20}, {"line": 4, "start": 4, "end": 51}, {"line": 18, "start": 2, "end": 25}], "source<->target": [{"line": 19, "start": 4, "end": 41}, {"line": 20, "start": 8, "end": 39}, {"line": 16, "start": 2, "end": 29}, {"line": 17, "start": 2, "end": 13}, {"line": 22, "start": 2, "end": 15}, {"line": 21, "start": 6, "end": 27}], "vertices": [{"line": 1, "start": 2, "end": 19}, {"line": 12, "start": 8, "end": 53}, {"line": 13, "start": 12, "end": 55}, {"line": 14, "start": 10, "end": 24}, {"line": 15, "start": 10, "end": 49}, {"line": 8, "start": 2, "end": 16}, {"line": 9, "start": 4, "end": 19}, {"line": 21, "start": 9, "end": 9}, {"line": 7, "start": 0, "end": 16}], "edge_sequence": [{"line": 10, "start": 4, "end": 22}, {"line": 11, "start": 6, "end": 29}]}, "source": "def scc(graph, query):\n  reachable = set()\n  vertices = set()\n  for edge in graph:\n    reachable.add((edge[\"source\"], edge[\"target\"]))\n    vertices.add(edge[\"source\"])\n    vertices.add(edge[\"target\"])\n  changed = True\n  while changed:\n    changed = False\n    for edge in graph:\n      for vertex in vertices:\n        if ((edge[\"source\"], vertex) not in reachable\n            and (edge[\"target\"], vertex) in reachable):\n          changed = True\n          reachable.add((edge[\"source\"], vertex))\n  source = query[0][\"source\"]\n  result = []\n  for vertex in vertices:\n    if ((source, vertex) in reachable and\n        (vertex, source) in reachable):\n      result.append(vertex)\n  return result", "author": "scott", "implementation": ""}, {"task": "scc", "language": "python-functional", "plan": {"source<->target": [{"line": 13, "start": 4, "end": 31}, {"line": 16, "start": 4, "end": 46}, {"line": 17, "start": 6, "end": 65}], "edge_sequence": [{"line": 4, "start": 12, "end": 44}, {"line": 5, "start": 12, "end": 29}], "edge_match": [{"line": 6, "start": 12, "end": 39}], "vertices": [{"line": 1, "start": 4, "end": 23}, {"line": 2, "start": 8, "end": 20}, {"line": 3, "start": 12, "end": 36}, {"line": 9, "start": 4, "end": 18}, {"line": 10, "start": 8, "end": 19}, {"line": 11, "start": 8, "end": 47}, {"line": 15, "start": 4, "end": 31}, {"line": 7, "start": 8, "end": 26}], "graph": [{"line": 14, "start": 4, "end": 68}]}, "source": "def scc(graph, query):\n    def step(relation):\n        return set([\n            (source, edge[\"target\"])\n            for (source, target) in relation\n            for edge in graph\n            if target == edge[\"source\"]\n        ]).union(relation)\n\n    def fix(f, x):\n        next = f(x)\n        return x if next == x else fix(f, next)\n\n    source = query[0][\"source\"]\n    init = set([(edge[\"source\"], edge[\"target\"]) for edge in graph])\n    reachable = fix(step, init)\n    return list(set([v for (_, v) in reachable\n      if (v, source) in reachable and (source, v) in reachable]))", "author": "scott", "implementation": ""}, {"task": "scc", "language": "datalog", "plan": {"edge_match": [{"line": 8, "start": 31, "end": 32}, {"line": 5, "start": 22, "end": 22}, {"line": 5, "start": 31, "end": 31}, {"line": 5, "start": 22, "end": 23}, {"line": 5, "start": 31, "end": 32}], "edge_sequence": [{"line": 4, "start": 14, "end": 25}, {"line": 5, "start": 13, "end": 36}], "graph": [{"line": 10, "start": 0, "end": 26}, {"line": 7, "start": 0, "end": 26}, {"line": 8, "start": 0, "end": 26}, {"line": 6, "start": 0, "end": 23}], "source<->target": [{"line": 0, "start": 0, "end": 32}, {"line": 1, "start": 0, "end": 24}, {"line": 2, "start": 0, "end": 37}, {"line": 9, "start": 0, "end": 35}], "vertices": [{"line": 3, "start": 0, "end": 32}, {"line": 4, "start": 0, "end": 26}, {"line": 5, "start": 0, "end": 37}]}, "source": ".decl scc1(x: symbol, y: symbol)\nscc1(x, x) :- vertex(x).\nscc1(x, y) :- path(x, y), path(y, x).\n.decl path(x: symbol, y: symbol)\npath(x, y) :- graph(x, y).\npath(x,y) :- graph(x, z), path(z, y).\n.decl vertex(x: symbol)\nvertex(x)  :- graph(x, _).\nvertex(x)  :- graph(_, x).\nscc(x) :- query(src), scc1(src, x).", "author": "scott", "implementation": ""}, {"task": "unique_product", "language": "python-imperative", "plan": {"count": [{"line": 3, "start": 2, "end": 21}], "check": [{"line": 4, "start": 4, "end": 31}, {"line": 2, "start": 2, "end": 37}, {"line": 3, "start": 2, "end": 21}], "name": [{"line": 5, "start": 6, "end": 17}, {"line": 6, "start": 2, "end": 13}]}, "source": "\ndef unique_product(list):\n  values = [l[\"value\"] for l in list]\n  for elem in values:\n    if values.count(elem) == 1:\n      return elem\n  return None\n", "author": "g", "implementation": ""}, {"task": "unique_product", "language": "python-pandas", "plan": {"check": [{"line": 3, "start": 4, "end": 23}], "name": [{"line": 2, "start": 15, "end": 42}, {"line": 3, "start": 24, "end": 30}, {"line": 2, "start": 14, "end": 42}]}, "source": "\ndef unique_product(list):\n  return list[list.groupby('value').value.\n    transform(len) == 1].value\n", "author": "g", "implementation": ""}, {"task": "unique_product", "language": "r", "plan": {"name": [{"line": 5, "start": 4, "end": 15}, {"line": 4, "start": 4, "end": 16}], "check": [{"line": 1, "start": 2, "end": 10}, {"line": 2, "start": 4, "end": 24}, {"line": 3, "start": 4, "end": 22}]}, "source": "unique_product <- function(list) {\n  list %>%\n    add_count(value) %>%\n    filter(n == 1) %>%\n    slice(1) %>%\n    pull(value)\n}", "author": "g", "implementation": ""}, {"task": "unique_product", "language": "q", "plan": {"check": [{"line": 1, "start": 2, "end": 41}, {"line": 2, "start": 8, "end": 23}], "name": [{"line": 2, "start": 2, "end": 23}]}, "source": "unique_product: {[items]\n  counts: count each group items[`value];\n  first where[counts=1]}", "author": "g", "implementation": ""}, {"task": "unique_product", "language": "sql", "plan": {"check": [{"line": 4, "start": 0, "end": 20}], "count": [], "name": [{"line": 1, "start": 0, "end": 12}, {"line": 2, "start": 0, "end": 9}, {"line": 3, "start": 0, "end": 14}]}, "source": "\nSELECT value\nFROM list\nGROUP BY value\nHAVING Count(*) == 1\n", "author": "g", "implementation": ""}, {"task": "unique_product", "language": "datalog", "plan": {"check": [{"line": 7, "start": 4, "end": 48}, {"line": 3, "start": 4, "end": 37}], "count": [{"line": 3, "start": 4, "end": 17}], "name": [{"line": 7, "start": 4, "end": 20}]}, "source": "\n.decl is_unique(Value:symbol)\nis_unique(Value) :-\n    list(_,Value), !not_unique(Value).\n    \n.decl not_unique(Value:symbol)\nnot_unique(Value) :- \n    list(id1,Value), list(id2,Value), id1 != id2.\n\nunique_product(value) :- is_unique(value).\n", "author": "g", "implementation": ""}, {"task": "unique_product", "language": "python-functional", "plan": {"count": [{"line": 3, "start": 14, "end": 31}], "check": [{"line": 3, "start": 32, "end": 55}], "name": [{"line": 3, "start": 9, "end": 32}, {"line": 2, "start": 2, "end": 37}]}, "source": "\ndef unique_product(list):\n  values = [l[\"value\"] for l in list]\n  return next(x for x in values if values.count(x) == 1)\n", "author": "g", "implementation": ""}, {"task": "continent_by_population", "language": "python-pandas", "plan": {"group": [{"line": 1, "start": 22, "end": 43}], "average": [{"line": 1, "start": 43, "end": 61}], "max": [{"line": 2, "start": 24, "end": 41}], "name": [{"line": 2, "start": 9, "end": 24}, {"line": 2, "start": 41, "end": 42}]}, "source": "def continent_by_population(countries):\n  mean_pop = countries.groupby('continent').population.mean()\n  return mean_pop.index[mean_pop.argmax()]", "author": "will", "implementation": ""}, {"task": "continent_by_population", "language": "sql", "plan": {"max": [{"line": 3, "start": 25, "end": 29}, {"line": 3, "start": 0, "end": 8}, {"line": 4, "start": 0, "end": 7}], "average": [{"line": 3, "start": 9, "end": 24}], "group": [{"line": 2, "start": 0, "end": 18}, {"line": 1, "start": 0, "end": 14}], "name": [{"line": 0, "start": 0, "end": 16}]}, "source": "SELECT continent \nFROM countries\nGROUP BY continent\nORDER BY AVG(population) DESC\nLIMIT 1", "author": "will", "implementation": ""}, {"task": "continent_by_population", "language": "datalog", "plan": {"max": [{"line": 10, "start": 2, "end": 69}, {"line": 9, "start": 2, "end": 41}], "group": [{"line": 3, "start": 18, "end": 45}, {"line": 4, "start": 26, "end": 53}], "name": [{"line": 8, "start": 2, "end": 29}, {"line": 7, "start": 24, "end": 33}], "average": [{"line": 5, "start": 2, "end": 30}, {"line": 4, "start": 2, "end": 26}, {"line": 3, "start": 2, "end": 18}, {"line": 2, "start": 2, "end": 29}, {"line": 0, "start": 0, "end": 54}, {"line": 1, "start": 0, "end": 37}]}, "source": ".decl average_population(Continent:symbol, Avg:number)\naverage_population(Continent, Avg) :-\n  countries(Continent, _, _),\n  Total = sum P : countries(Continent, _, P),\n  Num_countries = count : countries(Continent, _, _),\n  Avg = Total / Num_countries.\n  \ncontinent_by_population(Continent) :- \n  countries(Continent, _, _), \n  average_population(Continent, Max_avg),\n  Max_avg = max A : { countries(C, _, _), average_population(C, A) }.", "author": "will", "implementation": ""}, {"task": "continent_by_population", "language": "q", "plan": {"max": [{"line": 3, "start": 3, "end": 8}, {"line": 3, "start": 15, "end": 28}], "average": [{"line": 1, "start": 9, "end": 24}, {"line": 1, "start": 2, "end": 9}], "name": [{"line": 3, "start": 29, "end": 38}, {"line": 3, "start": 54, "end": 64}], "group": [{"line": 1, "start": 25, "end": 52}]}, "source": "averages: \n  select avg(population) by continent from countries;\ncontinent_by_population: \n  (first select[>population] continent from averages) `continent", "author": "will", "implementation": ""}, {"task": "continent_by_population", "language": "python-functional", "plan": {"group": [{"line": 3, "start": 33, "end": 52}, {"line": 4, "start": 17, "end": 48}], "name": [{"line": 6, "start": 2, "end": 3}, {"line": 2, "start": 29, "end": 30}, {"line": 8, "start": 5, "end": 15}, {"line": 9, "start": 8, "end": 18}, {"line": 11, "start": 42, "end": 45}, {"line": 11, "start": 2, "end": 8}, {"line": 3, "start": 5, "end": 15}, {"line": 5, "start": 4, "end": 31}, {"line": 1, "start": 2, "end": 55}, {"line": 2, "start": 2, "end": 30}, {"line": 7, "start": 2, "end": 14}, {"line": 9, "start": 4, "end": 7}, {"line": 9, "start": 24, "end": 51}, {"line": 10, "start": 2, "end": 3}], "max": [{"line": 11, "start": 9, "end": 42}], "average": [{"line": 8, "start": 16, "end": 37}, {"line": 9, "start": 19, "end": 23}, {"line": 3, "start": 17, "end": 32}, {"line": 9, "start": 24, "end": 51}, {"line": 9, "start": 4, "end": 7}, {"line": 10, "start": 2, "end": 3}, {"line": 7, "start": 2, "end": 14}, {"line": 2, "start": 2, "end": 30}, {"line": 6, "start": 2, "end": 3}, {"line": 5, "start": 4, "end": 31}]}, "source": "def continent_by_population(countries):\n  continents = set([c['continent'] for c in countries])\n  populations_by_continent = [\n    (continent, [c['population'] for c in countries \n                 if c['continent'] == continent])\n    for continent in continents\n  ]\n  averages = [\n    (continent, sum(pops) / len(pops))\n    for continent, pops in populations_by_continent\n  ]\n  return max(averages, key=lambda t: t[1])[0]", "author": "will", "implementation": ""}, {"task": "continent_by_population", "language": "python-imperative", "plan": {"name": [{"line": 15, "start": 2, "end": 22}, {"line": 7, "start": 2, "end": 22}, {"line": 13, "start": 6, "end": 31}, {"line": 9, "start": 2, "end": 16}, {"line": 9, "start": 32, "end": 59}, {"line": 3, "start": 4, "end": 36}, {"line": 1, "start": 2, "end": 32}, {"line": 1, "start": 46, "end": 47}, {"line": 4, "start": 4, "end": 30}, {"line": 5, "start": 4, "end": 30}], "max": [{"line": 11, "start": 4, "end": 52}, {"line": 12, "start": 6, "end": 27}, {"line": 8, "start": 2, "end": 20}, {"line": 9, "start": 2, "end": 5}, {"line": 9, "start": 32, "end": 59}], "average": [{"line": 9, "start": 17, "end": 31}, {"line": 10, "start": 4, "end": 27}, {"line": 4, "start": 30, "end": 58}, {"line": 5, "start": 30, "end": 38}], "group": [{"line": 2, "start": 2, "end": 27}, {"line": 3, "start": 16, "end": 36}]}, "source": "def continent_by_population(countries):\n  continent_stats = defaultdict(lambda: [0, 0])\n  for country in countries:\n    continent = country['continent']\n    continent_stats[continent][0] += country['population']\n    continent_stats[continent][1] += 1\n     \n  max_continent = None\n  max_average = None\n  for continent, [total, count] in continent_stats.items():\n    average = total / count\n    if max_average is None or max_average < average:\n      max_average = average\n      max_continent = continent\n      \n  return max_continent", "author": "will", "implementation": ""}, {"task": "continent_by_population", "language": "r", "plan": {"name": [{"line": 5, "start": 4, "end": 15}, {"line": 4, "start": 31, "end": 34}], "max": [{"line": 4, "start": 4, "end": 30}, {"line": 3, "start": 43, "end": 46}], "average": [{"line": 3, "start": 4, "end": 42}, {"line": 2, "start": 24, "end": 27}], "group": [{"line": 1, "start": 12, "end": 15}, {"line": 2, "start": 4, "end": 23}, {"line": 1, "start": 2, "end": 12}]}, "source": "continent_by_population <- function(countries) {\n  countries %>%\n    group_by(continent) %>%\n    summarize(mean_pop = mean(population)) %>%\n    slice(which.max(mean_pop)) %>%\n    .$continent\n}", "author": "will", "implementation": ""}, {"task": "strings_to_numbers", "language": "python-pandas", "plan": {"cond": [{"line": 2, "start": 4, "end": 51}], "clean": [{"line": 3, "start": 15, "end": 41}], "number": [{"line": 3, "start": 41, "end": 42}, {"line": 3, "start": 4, "end": 15}], "iter": [{"line": 4, "start": 9, "end": 48}]}, "source": "def strings_to_numbers(numbers):\n  def convert(row):\n    sep = \",\" if row.format == 'comma_sep' else \"_\"\n    return int(row.value.replace(sep, \"\"))\n  return numbers.apply(convert, axis=1).tolist()", "author": "will", "implementation": ""}, {"task": "strings_to_numbers", "language": "sql", "plan": {"cond": [{"line": 1, "start": 8, "end": 19}, {"line": 4, "start": 6, "end": 18}, {"line": 5, "start": 8, "end": 34}, {"line": 6, "start": 8, "end": 34}, {"line": 7, "start": 6, "end": 9}], "clean": [{"line": 2, "start": 26, "end": 49}, {"line": 3, "start": 26, "end": 49}, {"line": 2, "start": 4, "end": 12}, {"line": 3, "start": 6, "end": 13}, {"line": 7, "start": 9, "end": 14}], "number": [{"line": 1, "start": 2, "end": 7}, {"line": 8, "start": 4, "end": 15}], "iter": [{"line": 9, "start": 0, "end": 12}]}, "source": "SELECT \n  CAST(\n    REPLACE(\n      value, \n      CASE format \n        WHEN \"comma_sep\" THEN \",\" \n        WHEN \"under_sep\" THEN \"_\" \n      END, \"\")\n    AS integer)\nFROM numbers", "author": "will", "implementation": ""}, {"task": "strings_to_numbers", "language": "datalog", "plan": {"number": [{"line": 13, "start": 2, "end": 22}], "cond": [{"line": 6, "start": 2, "end": 37}, {"line": 7, "start": 3, "end": 38}, {"line": 1, "start": 0, "end": 28}], "clean": [{"line": 2, "start": 0, "end": 32}, {"line": 3, "start": 2, "end": 34}, {"line": 4, "start": 2, "end": 19}, {"line": 5, "start": 2, "end": 26}, {"line": 8, "start": 2, "end": 33}, {"line": 9, "start": 3, "end": 44}, {"line": 12, "start": 2, "end": 40}, {"line": 0, "start": 0, "end": 62}], "iter": [{"line": 1, "start": 29, "end": 50}]}, "source": ".decl clean(Format:symbol, Inp:symbol, I:number, Outp:symbol) \nclean(Format, Inp, 0, \"\") :- numbers(Format, Inp).\nclean(Format, Inp, I+1, Outp) :-\n  clean(Format, Inp, I, Outp_rec),\n  I <= strlen(Inp),\n  Chr = substr(Inp, I, 1),\n  ((Format = \"comma_sep\", Sep = \",\");\n   (Format = \"under_sep\", Sep = \"_\")),\n  ((Chr  = Sep, Outp = Outp_rec);\n   (Chr != Sep, Outp = cat(Outp_rec, Chr))).\n\nstrings_to_numbers(N) :-\n  clean(Format, Inp, strlen(Inp), Outp),\n  N = to_number(Outp).", "author": "will", "implementation": ""}, {"task": "strings_to_numbers", "language": "q", "plan": {"cond": [{"line": 1, "start": 2, "end": 56}], "clean": [{"line": 2, "start": 8, "end": 25}], "number": [{"line": 2, "start": 2, "end": 7}], "iter": [{"line": 5, "start": 2, "end": 45}]}, "source": "convert: {[val; format] \n  sep: ((\"comma_sep\"; \"under_sep\") ! (\",\"; \"_\")) format;\n  \"J\" $ ssr[val; sep; \"\"]}\n  \nstrings_to_numbers:\n  convert'[numbers[`value]; numbers[`format]]", "author": "will", "implementation": ""}, {"task": "strings_to_numbers", "language": "python-functional", "plan": {"iter": [{"line": 1, "start": 2, "end": 10}, {"line": 4, "start": 4, "end": 30}, {"line": 5, "start": 2, "end": 3}], "number": [{"line": 2, "start": 4, "end": 8}, {"line": 3, "start": 55, "end": 56}], "clean": [{"line": 2, "start": 8, "end": 29}, {"line": 3, "start": 50, "end": 55}], "cond": [{"line": 3, "start": 6, "end": 50}]}, "source": "def strings_to_numbers(numbers):\n  return [\n    int(row[\"value\"].replace(\n      \",\" if row[\"format\"] == \"comma_sep\" else \"_\", \"\"))\n    for row in numbers\n  ]", "author": "will", "implementation": ""}, {"task": "strings_to_numbers", "language": "python-imperative", "plan": {"iter": [{"line": 1, "start": 1, "end": 13}, {"line": 7, "start": 4, "end": 18}, {"line": 7, "start": 52, "end": 53}, {"line": 2, "start": 2, "end": 21}], "cond": [{"line": 3, "start": 4, "end": 36}, {"line": 4, "start": 6, "end": 15}, {"line": 5, "start": 4, "end": 9}, {"line": 6, "start": 6, "end": 15}], "number": [{"line": 7, "start": 18, "end": 22}, {"line": 7, "start": 51, "end": 52}], "clean": [{"line": 7, "start": 22, "end": 51}]}, "source": "def strings_to_numbers(numbers):\n  output = []\n  for row in numbers:\n    if row[\"format\"] == 'comma_sep':\n      sep = \",\"\n    else:\n      sep = \"_\"\n    output.append(int(row[\"value\"].replace(sep, \"\")))\n  return output", "author": "will", "implementation": ""}, {"task": "strings_to_numbers", "language": "r", "plan": {"cond": [{"line": 3, "start": 13, "end": 52}], "clean": [{"line": 2, "start": 31, "end": 47}, {"line": 3, "start": 6, "end": 13}, {"line": 3, "start": 52, "end": 57}], "number": [{"line": 2, "start": 20, "end": 31}, {"line": 3, "start": 57, "end": 58}], "iter": [{"line": 1, "start": 2, "end": 13}, {"line": 2, "start": 4, "end": 20}, {"line": 3, "start": 58, "end": 63}, {"line": 4, "start": 4, "end": 16}]}, "source": "strings_to_numbers <- function(numbers) {\n  numbers %>%\n    mutate(output = as.numeric(str_replace_all(\n      value, ifelse(format == \"comma_sep\", \",\", \"_\"), \"\"))) %>%\n    pull(output)\n}", "author": "will", "implementation": ""}, {"task": "average_adjacent", "language": "sql", "plan": {"order": [{"line": 3, "start": 28, "end": 41}, {"line": 4, "start": 2, "end": 11}, {"line": 2, "start": 6, "end": 12}, {"line": 3, "start": 2, "end": 6}, {"line": 2, "start": 0, "end": 4}, {"line": 6, "start": 0, "end": 13}], "pair adjacent": [{"line": 3, "start": 8, "end": 50}, {"line": 0, "start": 0, "end": 6}, {"line": 1, "start": 2, "end": 8}, {"line": 5, "start": 0, "end": 22}], "average": [{"line": 1, "start": 8, "end": 28}]}, "source": "SELECT\n  time, (x + next) / 2 as x\nFROM (SELECT\n  time, x, LEAD(x, 1) OVER (ORDER BY time) as next\n  FROM data)\nWHERE next is not null\nORDER BY time", "author": "scott", "implementation": ""}, {"task": "average_adjacent", "language": "python-imperative", "plan": {"order": [{"line": 5, "start": 2, "end": 36}], "pair adjacent": [{"line": 7, "start": 2, "end": 24}, {"line": 8, "start": 2, "end": 13}, {"line": 9, "start": 2, "end": 24}, {"line": 10, "start": 4, "end": 44}, {"line": 6, "start": 2, "end": 40}, {"line": 12, "start": 4, "end": 24}, {"line": 13, "start": 2, "end": 15}], "average": [{"line": 1, "start": 2, "end": 20}, {"line": 2, "start": 4, "end": 13}, {"line": 3, "start": 2, "end": 20}, {"line": 4, "start": 4, "end": 25}, {"line": 11, "start": 4, "end": 62}]}, "source": "def average_adjacent(data):\n  if len(data) == 0:\n    return []\n  if len(data) == 1:\n    return [data[0][\"x\"]]\n  data.sort(key=lambda v: v[\"time\"])\n  previous, current = None, data[0][\"x\"]\n  time = data[0][\"time\"]\n  result = []\n  for value in data[1:]:\n    previous = current; current = value[\"x\"]\n    result.append({\"time\": time, \"x\": (previous + current)/2})\n    time = value[\"time\"]\n  return result", "author": "scott", "implementation": ""}, {"task": "average_adjacent", "language": "python-functional", "plan": {"order": [{"line": 1, "start": 0, "end": 48}], "pair adjacent": [{"line": 2, "start": 2, "end": 10}, {"line": 3, "start": 4, "end": 23}, {"line": 5, "start": 0, "end": 43}, {"line": 6, "start": 2, "end": 3}], "average": [{"line": 4, "start": 0, "end": 35}]}, "source": "def average_adjacent(data):\n  data = sorted(data, key=lambda v: v[\"time\"])\n  return [\n    {\"time\": v[\"time\"],\n     \"x\": (v[\"x\"] + next[\"x\"]) / 2}\n    for next, v in zip(data[1:], data[:-1])\n  ]", "author": "scott", "implementation": ""}, {"task": "average_adjacent", "language": "python-pandas", "plan": {"average": [{"line": 4, "start": 2, "end": 39}, {"line": 5, "start": 2, "end": 16}], "order": [{"line": 1, "start": 2, "end": 33}], "pair adjacent": [{"line": 2, "start": 2, "end": 43}, {"line": 3, "start": 2, "end": 44}]}, "source": "def average_adjacent(data):\n  data = data.sort_values(\"time\")\n  lagging = data[1:].reset_index(drop=True)\n  leading = data[:-1].reset_index(drop=True)\n  leading.x = (lagging.x + leading.x)/2\n  return leading", "author": "scott", "implementation": ""}, {"task": "average_adjacent", "language": "datalog", "plan": {"order": [{"line": 0, "start": 0, "end": 32}, {"line": 1, "start": 0, "end": 44}], "pair adjacent": [{"line": 7, "start": 27, "end": 44}, {"line": 7, "start": 46, "end": 72}, {"line": 5, "start": 0, "end": 51}, {"line": 6, "start": 27, "end": 72}, {"line": 4, "start": 0, "end": 37}, {"line": 2, "start": 0, "end": 40}, {"line": 3, "start": 0, "end": 45}, {"line": 7, "start": 2, "end": 20}, {"line": 8, "start": 2, "end": 29}, {"line": 6, "start": 0, "end": 26}], "average": [{"line": 7, "start": 74, "end": 87}, {"line": 6, "start": 74, "end": 88}, {"line": 9, "start": 2, "end": 15}]}, "source": ".decl less(x: number, y: number)\nless(x, y) :- data(x, _), data(y, _), x < y.\n.decl intermediate(x: number, y: number)\nintermediate(x, y) :- less(x, z), less(z, y).\n.decl immediate(x: number, y: number)\nimmediate(x, y) :- less(x, y), !intermediate(x, y).\naverage_adjacent(t1, v) :-\n  immediate(t1, t2),\n  data(t1, v1), data(t2, v2),\n  v = (v1+v2)/2.", "author": "scott", "implementation": ""}]